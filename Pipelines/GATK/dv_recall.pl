#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use IO::Dir;
use IO::File;
use Data::Dumper;
use Perl6::Slurp;
use FindBin qw|$Bin|;
use File::Copy;
use File::Path qw|make_path|;
use File::Basename;
use Version::Compare;
use Cwd qw|abs_path|;
use Getopt::Lucid qw|:all|;
use List::MoreUtils qw|all uniq|;
use Config::Std;
use String::ShellQuote;
use Genome::Ranges::IntSet;
use Utils::Workflow;
use Utils::Hash qw|merge_conf|;
use Utils::File::Iter qw|iter_file|;


use lib "$Bin/../lib/";
use Shared qw|read_list parse_tabfile|;


############################
## Command line interface ##
############################

my @spec =  (
	Param("conf|c")->valid(sub { -r }),
	Param("list|l")->valid(sub { -r }),
	Param("tab")->valid(sub { -r }),
	Param("ped")->valid(sub { -r }),
	Param("prefix"),
	Param("rename")->valid(sub { -r }),
	Param("remove")->valid(sub { -r }),
	Param("outdir|out"),
	Param("engine|eng")->valid(sub { $_ eq 'SGE' || $_ eq 'BASH' }),
	Keypair("param|par"),
	Switch("help|h"),
	Switch("local"),
	Switch("dryrun|dry"),
	Switch("force")
	);

my $opt = Getopt::Lucid->getopt(\@spec);

if ($opt->get_help) {
	print STDERR <<EOF;
Purpose:
	This is a pipeline script used to re-call ("in silico validate") selected variants of each individual 
	and his/her family members using DeepVariant.  

Usage:
	dv_recall.pl --conf Config --list CRAMList [--tab VarTab] --outdir WorkDir

Options:
	--list: BAM/CRAM/VCF file list or directory. The list file can have 1 or 2 columns per line. 
			If the list have 2 columns, the second column will be used as sample ID.
			Otherwise, file basename after stripping off suffix will be used as sample ID.
	--prefix : The output file prefix, default will be the basename of input table file. 
	--tab : The variant table. It overrides the file specified in the config.
	--ped : The pedigree file. It overrides the file specified in the config.
	--rename : Rename original BAM/CRAM/VCF files to match sample IDs in the variants table file.
			Original sample ID for BAM/CRAM/VCF is the second column in the list or basename, but not ID tag in the header.
	--remove : Sample removal list. In case of renaming, new IDs should be used in removal list.

Notes:
	The input variant table is a tab delimited text file with each row representing a variant in an individual. 
	Sequence alignments around each variant in individual level BAM/CRAM files are used by DeepVariant for re-calling
	the variant. If pedigree file is provided, family members will also be evaluated and results for all family members
	will be shown in the output.

	If DeepVariant has been applied genome-wide to call variants, then individual level VCF file can be used directly
	to extract DeepVariant calls. The input VCFs can only have one sample per file. If multi-sample VCF generated by
	GLnexus+DeepVariant workflow is available, individual level VCF should first be extracted by keep variant that are
	non-reference calls in each individual (using bcftools). Note: gVCF files are also supported now, file name suffix
	can be .g.vcf.gz or .gvcf.gz. 

	The script is designed to analyze small number of variants per sample. There will be one DeepVariant task for each
	individual running on the regions nearby each input variants. If large number of variants per individual
	need to be re-called. It is better to run DeepVariant to do genome-wide variant discovery first, then use
	dv_recall2.pl to collect DeepVariant results from VCFs.

	(For advanced use) If genome assembly in the variant table does not match BAM/CRAM files, liftover can be performed
	before running DV. This require a new section in the config file providing path to chain file and reference sequence.
	When liftover is used variants that cannot be mapped back to the primary assembly from the new genome build will be 
	ignored. Liftover is not supported when input are gVCF files.
 
Output:
	FILTER and QUAL of DeepVariant calls are collected and appended to the original variant table. We also listed nearby
	variants (within distance specified in the config) called in the same individual. Whem DeepVariant calls from family
	members are available, family members who carried the variant will be listed in additional columns.

Dependencies:
	DeepVariant is run using Docker. Other external tools used include: bgzip/tabix, bedtools for extracting variants
	from VCF, and CrossMap (v0.2.7) when liftover is used.

EOF
	exit 1;
}

$opt->validate({requires => [qw|conf list outdir|]});

my $rootdir = $opt->get_outdir;

my %conf = merge_conf($opt->get_conf, $opt->get_param); 
$conf{PATH}{MODULE} = shell_quote("$Bin/module");


my $outfile;
if ($opt->get_prefix) {
	my $prefix = $opt->get_prefix;
	if ($prefix !~ /\.txt$/) {
		$outfile = $prefix.".txt";
	}
	else {
		$outfile =$prefix;
	}
}
else {
	if ($opt->get_tab) {
		$outfile = basename($opt->get_tab);
	}
	else {
		$outfile = basename($conf{INPUT}{FILE});
	}
}
$conf{PATH}{OUTPUT} = $outfile;

my %remote;
if ($opt->get_local) {
	$remote{remote} = $conf{REMOTE}{HOST};
	if ($conf{REMOTE}{NOTEST} =~ /^Y|T/ ) {
		$remote{notest} = 1;
	}
}

# Input can be BAM/CRAMs, or can also be DeepVariant VCFs per-individual 
my ($bams, $filetype) = read_list($opt->get_list, 
	{ suffix => ['bam', 'cram', 'g.vcf.gz', 'vcf.gz', 'gvcf.gz'], %remote,
	  rename => $opt->get_rename, remove => $opt->get_remove });
print STDERR "Finished reading $filetype file list\n";

# Get family ID for each sample, and samples in each family
my (%fids, %famsamps);
if ($opt->get_ped) {
	$conf{PED}{FILE} = $opt->get_ped;
}
if (exists $conf{PED}) {
	unless(-f $conf{PED}{FILE}) {
		die "Cannot find PED file $conf{PED}{FILE}";
	}
	$conf{PED}{OPTION} = "--ped $conf{PED}{FILE} ";
	%fids = map { (split)[1,0] } slurp $conf{PED}{FILE};
	while(my ($iid, $fid) = each %fids) {
		push @{$famsamps{$fid}}, $iid;
	}
	if (defined $conf{PED}{IGNORE}) {
		$conf{PED}{OPTION} .= "--ped-ignore $conf{PED}{IGNORE} ";
	}
	if (defined $conf{PED}{TWINS}) {
		$conf{PED}{OPTION} .= "--ped-twins $conf{PED}{TWINS} ";
	}
}
else {
	$conf{PED}{OPTION} = "";
}


#######################################################################
# Parse input file to prepare sample-specific variant calling intervals
#######################################################################

my $wkf = Utils::Workflow->new($rootdir,
	{ engine => $opt->get_engine, force => $opt->get_force, strict_var => 1 });

# If liftover is required
# We will update the chrom/pos/ref/alt to the new assembly, and store the original
# coordinates in a new field that can be un packed later.
# We will also need to do liftover on DeepVariant's VCF output.

if (defined $conf{LIFTOVER}) {
	if ($filetype eq 'gvcf.gz' || $filetype eq 'g.vcf.gz') {
		print STDERR "Liftover is not supported for gVCF input!";
		exit 1;
	}

	unless(all { defined $conf{LIFTOVER}{$_} } qw|CHAIN CHAINBACK OPTION OPTIONBACK FASTABACK|) {
		die "Must provide CHAIN, CHAINBACK, OPTION, OPTIONBACK, FASTABACK for LIFTOVER";
	}
	unless (defined $conf{PATH}{FASTABACK}) {
		die "Must provide FASTA file for variants after backward liftover";
	}
	my $oldinfile;
	if ($opt->get_tab) {
		$oldinfile = $opt->get_tab;
	}
	else {
		$oldinfile = $conf{INPUT}{FILE};
	}
	unless (-f $oldinfile) {
		croak "Cannot find original input table file: $oldinfile ";
	}
	# liftover, it must be run here because we need to collect regions around variants after liftover
	print STDERR "Perform liftover to change genome coordinates of variants\n";
	my $varcols = join(',', (split(',', $conf{INPUT}{FIELDS}))[1..4]);
	system("liftover_vars.pl --input $oldinfile --chain $conf{LIFTOVER}{CHAIN} --seq $conf{PATH}{FASTA} ".
		   "--fields $varcols --fsep '\t' --oldvar _VarID $conf{LIFTOVER}{OPTION} --output $rootdir/par/input");	
	$conf{INPUT}{FILE} = "$rootdir/par/input.txt";
	$conf{SUMRES}{OPTION} = "--oldvar $conf{LIFTOVER}{OLDVAR}"
}
else {
	if ($opt->get_tab) {
		$conf{INPUT}{FILE} = $opt->get_tab;
	}
	unless (-f $conf{INPUT}{FILE}) {
		croak "Cannot find input table file: $conf{INPUT}{FILE}";
	}
	$conf{SUMRES}{OPTION} = "";
}


my @samps;
# Parse input variant file
{
	my ($it, $fnames, $input_fields) =
		parse_tabfile($conf{INPUT}{FILE}, $conf{INPUT}{FIELDS}, 5);

	my %sprngs;
	while(my $dat = $it->()) {
		my ($iid, $chr, $pos, $ref, $alt) = @{$dat}{@$input_fields};
		$pos =~ s/,//g;
		push @{$sprngs{$iid}}, [$chr, $pos-$conf{INPUT}{PADDING}, 
								$pos+length($ref)-1+$conf{INPUT}{PADDING}];
		if (defined $fids{$iid}) {
			foreach my $sampid (@{$famsamps{$fids{$iid}}}) {
				next if $sampid eq $iid;
				push @{$sprngs{$sampid}}, [$chr, $pos-$conf{INPUT}{PADDING}, 
										   $pos+length($ref)-1+$conf{INPUT}{PADDING}];
			}
		}
	}

	my $nsamp = scalar(keys %sprngs);
	my $nincl = grep { defined $bams->{$_} } keys %sprngs; 
	if (exists $conf{PED}) {
		print STDERR "A total of $nsamp samples and their family members are found in the variants table, ",
			"$nincl of them have $filetype files available for DV recall.\n";
	}
	else {
		print STDERR "A total of $nsamp samples found in the variants table, ",
			"$nincl of them have $filetype files available for DV recall.\n";
	}
	
	unless ($nsamp > 0) {
		print STDERR "No sample found in the variant table with BAM/CRAM files\n";
		exit 1;
	}

	@samps = sort grep { defined $bams->{$_} } keys %sprngs;
	# Will only focus on sample can be found in the list file

	# Merge and write sample-specific intervals
	for (my $ii = 0; $ii < @samps; $ii ++) {
		my $iid = $samps[$ii];
		my $jj = $ii + 1;
		open my $fout, ">$rootdir/par/IID2BAM.$jj" or die "Cannot write to IID2BAM";
		print $fout $iid, "\t", abs_path($bams->{$iid}), "\n";
		make_path "$rootdir/wrk/$iid";
		my $unionrng = Genome::Ranges::IntSet->new($sprngs{$iid})->to_ranges();
		$unionrng->write("$rootdir/wrk/$iid/ranges.bed", {bed => 1});
		#my @regions;
		#my $iter = $unionrng->iter();
		#while(my $dat = $iter->()) {
		#	push @regions, sprintf("%s:%d-%d", @$dat);
		#}
		#open my $frng, ">$rootdir/wrk/$iid/bam_regions.txt" or die "Cannot write to bam_regions.txt";
		#print $frng join(" ", @regions), "\n";
	}
}

write_config %conf, "$rootdir/par/run.conf" unless $opt->get_dryrun;


#################################
##  Workflow initialization    ##
#################################

my %deparg;
if ($opt->get_local) {
	unless($filetype eq 'bam' || $filetype eq 'cram') {
		die "--local option can only be used to fetch BAM/CRAM files!";
	}
	$wkf->add(extract_bams(), { name => "ExtractBAMs",
			expect => [ map { ["wrk/$_/regions.bam", "wrk/$_/regions.bam.bai"] } @samps ],
			nslots => scalar(@samps) });
	$deparg{depend} = "ExtractBAMs";
	$deparg{deparray} = 1;
}

# Synatx change since version 0.8.0
if ($filetype eq 'bam' || $filetype eq 'cram') {
	if (Version::Compare::version_compare($conf{DEEPVARIANT}{VERSION},"0.8.0")>=0) {
		if (lc($filetype) eq 'cram') {
			$conf{DEEPVARIANT}{CRAMOPT} = "--use_ref_for_cram=true";
		}
		else {
			$conf{DEEPVARIANT}{CRAMOPT} = "";
		}
	}
	else {
		unless(all { -f "$conf{DEEPVARIANT}{MODEL}.$_" } qw|data-00000-of-00001 index meta|) {
			die "Cannot find all deepvariant model related files";
		}
		$conf{DEEPVARIANT}{CRAMOPT} = "";
	}
}
#
#	$wkf->add(dv_run(), 
#		{ name => "DVCall", expect => [map { ["wrk/$_.vcf.gz", "wrk/$_.vcf.gz.tbi"] } @samps],
#			%deparg, nslots => scalar(@samps) });
#}
#else {
# Note: we still seperately run make_example and calling
# the combined workflow does not work when no variants found in the given region
if ($filetype eq 'bam' || $filetype eq 'cram') {
	$wkf->add(dv_examples(), 
			{ name => "DVExamps", expect => [map { "wrk/$_/examples.tfrecords.gz" } @samps], 
				%deparg, nslots => scalar(@samps) })
		->add(dv_call(),  # Note: not all DV call will generate a VCF.
			{ name => "DVCall", 
			  expect => [map { my $jj = $_ + 1; 
			  	["wrk/$samps[$_].variants.tfrecords.gz", "log/DVExamps.$jj.err" ] } 0..$#samps],
			  callback => \&check_dvcall,
			  nslots => scalar(@samps), depend =>  "DVExamps", deparray => 1});
}
else {
	$wkf->add(dv_collect(), 
			{ name => 'DVCall', 
			  expect => [map { ["wrk/$samps[$_].vcf.gz", "wrk/$samps[$_].vcf.gz.tbi"] } 0..$#samps],
			  nslots => scalar(@samps) });	
}

$wkf->add(sum_res(), 
		{ name => "SumRes", expect => "out/$outfile", depend => "DVCall" });


$wkf->inst(\%conf);
$wkf->run({ conf => $conf{$wkf->{engine}}, dryrun => $opt->get_dryrun  });


############################
## Workflow components    ##
############################

# Extract BAMs from remote server
sub extract_bams {
	my $script;
	if ($conf{REMOTE}{HOST} =~ /localhost/i) {
		$script = <<'EOF'; 

read IID BAM < _PARDIR_/IID2BAM._INDEX_

_REMOTE.SAMTOOLS_ view -T _REMOTE.FASTA_ -Ch -L _WRKDIR_/$IID/ranges.bed -M \
	-o _WRKDIR_/$IID/regions.cram $BAM

samtools index_WRKDIR_/$IID/regions.cram

EOF
	}
	else {
		$script = <<'EOF';

read IID BAM < _PARDIR_/IID2BAM._INDEX_

cat _WRKDIR_/$IID/ranges.bed | \
	ssh _REMOTE.HOST_ \
	"_REMOTE.SAMTOOLS_ view -T _REMOTE.FASTA_ -Ch -L - -M -o - $BAM" \
	> _WRKDIR_/$IID/regions.cram

samtools index _WRKDIR_/$IID/regions.cram

EOF
	}
	return $script;
}

# Liftover original input
# We did not make it as part of pipeline
sub liftover_vars {
	my $script = <<'EOF';

liftover_vars.pl --input _INPUT.OLDFILE_ --chain _LIFTOVER.CHAIN_ --seq _PATH.FASTA_ \
	--fields _INPUT.FIELDS_ --fsep '\t' --oldvar _LIFTOVER.OLDVAR_ _LIFTOVER.OPTION_ --output _PARDIR_/input;	

EOF
}

sub dv_examples {
	my $script = <<'EOF';

read IID BAM < _PARDIR_/IID2BAM._INDEX_

if [[ -f _WRKDIR_/$IID/regions.cram ]]; then 
	BAM=_WRKDIR_/$IID/regions.cram
fi

EOF
	if (!defined $conf{DEEPVARIANT}{Docker} || $conf{DEEPVARIANT}{Docker} =~/^Y|T/) {
		$script .= <<'EOF';

FADIR=$(dirname _PATH.FASTA_)
BAMDIR=$(dirname $BAM)
ROOTDIR=$(dirname _WRKDIR_)

docker run --rm \
    -v $FADIR:$FADIR -v $BAMDIR:$BAMDIR -v $ROOTDIR:$ROOTDIR \
	gcr.io/deepvariant-docker/deepvariant:_DEEPVARIANT.VERSION_ \
	/opt/deepvariant/bin/make_examples \
	--mode calling \
	--ref _PATH.FASTA_ \
	--reads $BAM _DEEPVARIANT.CRAMOPT_ \
	--regions _WRKDIR_/$IID/ranges.bed \
	--examples _WRKDIR_/$IID/examples.tfrecords.gz

EOF
	}
	else {
		if (exists $conf{CONDA}) {
			$script .= <<'EOF';
source _CONDA.INIT_
conda activate _CONDA.ENV_
EOF
		}
		$script .= <<'EOF';

python _DEEPVARIANT.BINPATH_/make_examples.zip \
	--mode calling \
	--ref _PATH.FASTA_ \
	--reads $BAM  _DEEPVARIANT.CRAMOPT_ \
	--regions _WRKDIR_/$IID/ranges.bed \
	--examples _WRKDIR_/$IID.examples.tfrecords.gz

EOF
	}
	return $script;
}

sub dv_call {
	my $script = "\nread IID BAM < _PARDIR_/IID2BAM._INDEX_\n";
	if (!defined $conf{DEEPVARIANT}{Docker} || $conf{DEEPVARIANT}{Docker} =~/^Y|T/) {
		$script .= <<'EOF';

MODIR=$(dirname _DEEPVARIANT.MODEL_)
ROOTDIR=$(dirname _WRKDIR_)
FADIR=$(dirname _PATH.FASTA_)

docker run --rm \
    -v $MODIR:$MODIR -v $ROOTDIR:$ROOTDIR \
	gcr.io/deepvariant-docker/deepvariant:_DEEPVARIANT.VERSION_ \
	/opt/deepvariant/bin/call_variants \
	--outfile _WRKDIR_/$IID.variants.tfrecords.gz \
	--examples _WRKDIR_/$IID/examples.tfrecords.gz \
	--checkpoint _DEEPVARIANT.MODEL_

docker run --rm \
    -v $FADIR:$FADIR -v $ROOTDIR:$ROOTDIR \
	gcr.io/deepvariant-docker/deepvariant:_DEEPVARIANT.VERSION_ \
	/opt/deepvariant/bin/postprocess_variants \
	--ref _PATH.FASTA_ \
	--infile _WRKDIR_/$IID.variants.tfrecords.gz \
	--outfile _WRKDIR_/$IID.vcf

EOF
	}
	else {
		if (exists $conf{CONDA}) {
		$script .= <<'EOF';
source _CONDA.INIT_
conda activate _CONDA.ENV_

EOF
		}
		$script .= <<'EOF';

python _DEEPVARIANT.BINPATH_/call_variants.zip \
	--outfile _WRKDIR_/$IID.variants.tfrecords.gz \
	--examples _WRKDIR_/$IID.examples.tfrecords.gz \
	--checkpoint _DEEPVARIANT.MODEL_

python _DEEPVARIANT.BINPATH_/postprocess_variants.zip \
	--ref _PATH.FASTA_ \
	--infile _WRKDIR_/$IID.variants.tfrecords.gz \
	--outfile _WRKDIR_/$IID.vcf


EOF
	}

	if (defined $conf{LIFTOVER}) {
		$script .= <<'EOF';
if [[ -f _WRKDIR_/$IID.vcf ]]; then
	liftover_vcf.pl --invcf _WRKDIR_/$IID.vcf --output _WRKDIR_/$IID \
		--chain _LIFTOVER.CHAINBACK_ --seq _LIFTOVER.FASTABACK_ \
		--wrkdir _TMPDIR_/$IID _LIFTOVER.OPTIONBACK_
fi

EOF
	}
	else {
		$script .= <<'EOF';
if [[ -f _WRKDIR_/$IID.vcf ]]; then
	bgzip _WRKDIR_/$IID.vcf 
	tabix -p vcf _WRKDIR_/$IID.vcf.gz
fi

EOF
	}
	return $script;
}

# Collect DeepVariant calls from VCFs directly
# If no variant can be found in VCF, it will contain only header
# Extract variants will be stored in a .vcf file even if the input is gvcf.
sub dv_collect {
	my $script = <<'EOF';

read IID VCF < _PARDIR_/IID2BAM._INDEX_

# bedtools dost not make use of tabix index and is too slow
#bedtools intersect -a $VCF -b _WRKDIR_/$IID/ranges.bed -wa -u -header > _WRKDIR_/$IID.vcf
tabix -p vcf -h -R _WRKDIR_/$IID/ranges.bed $VCF > _WRKDIR_/$IID.vcf

EOF
	if (defined $conf{LIFTOVER}) {
		$script .= <<'EOF';
NVAR=$(grep -v "^#" _WRKDIR_/$IID.vcf | wc -l)

# Test first if VCF is empty 
if [[ -f _WRKDIR_/$IID.vcf && $NVAR != 0 ]]; then
	NVAR=$(grep -v '^#' _WRKDIR_/$IID.vcf | wc -l | awk '{print $1}')
	if [[ $NVAR != 0 ]]; then
		liftover_vcf.pl --invcf _WRKDIR_/$IID.vcf --output _WRKDIR_/$IID \
			--chain _LIFTOVER.CHAINBACK_ --seq _LIFTOVER.FASTABACK_ \
			--wrkdir _TMPDIR_/$IID _LIFTOVER.OPTIONBACK_
	else
		bgzip _WRKDIR_/$IID.vcf
		tabix -p vcf _WRKDIR_/$IID.vcf.gz
	fi
fi
EOF
	}
	else {
		$script .= <<'EOF';
if [[ -f _WRKDIR_/$IID.vcf && $NVAR != 0 ]]; then
	bgzip _WRKDIR_/$IID.vcf 
	tabix -p vcf _WRKDIR_/$IID.vcf.gz
fi

EOF
	}
}

sub check_dvcall {
	my (@exp) = @_;
	if (all { -f "$rootdir/$_" } @exp) {
		# Read last line of error log
		open my $fin, "$rootdir/$exp[1]" or die "Cannot open $rootdir/$exp[1]";
		my $last_line;
		$last_line = $_, while (<$fin>);
		unless ($last_line =~ /Created 0 examples/) {
			my $fbase = basename($exp[0]);
			(my $iid = $fbase) =~ s/\.variants\.tfrecords\.gz$//;
			if (-f "$rootdir/wrk/$iid.vcf.gz") {
				return 1;
			}
			else {
				return 0;
			}
		}
		else {
			return 1;
		}
	}
	else {
		return 0;
	}
}

sub sum_res {
	my $script = <<'EOF';

perl _PATH.MODULE_/sum_dvrecall.pl \
	--input _INPUT.FILE_ --fields _INPUT.FIELDS_ \
	--fasta _PATH.FASTA_ --dvout _WRKDIR_ \
	--output _OUTDIR_/_PATH.OUTPUT_  _SUMRES.OPTION_ _PED.OPTION_ \
	--fields-add _OUTPUT.OUTFIELDS_ --nearby _OUTPUT.NEARBY_

EOF
	if (defined $conf{LIFTOVER}) {
		$script =~ s/FASTA/FASTABACK/;
	}	
	return $script;
}



