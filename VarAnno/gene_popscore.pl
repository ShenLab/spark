use strict;
use warnings;
use List::MoreUtils qw|all|;
use FindBin qw|$Bin|;
use IO::Dir;
use Hash::Util qw|lock_hash_recurse|;
use Cwd qw|abs_path|;
use Data::Dumper;
use Config::Std;
use Getopt::Lucid qw|:all|;
use Utils::Hash qw|merge_conf|;
use Utils::File qw|count_line|;
use Utils::Workflow;

use lib "$Bin/../lib";
use Shared qw|parse_tabfile slurp_xref |;

############################
## Command line interface ##
############################

my @spec =  (
	Param("conf|c")->valid(sub { -r }),
	Param("indir|in")->valid(sub { -r }),
	Param("outdir|out"),
	Param("engine|eng")->valid(sub { $_ eq 'SGE' || $_ eq 'BASH' }),
	Keypair("param|par"),
	Switch("help|h"),
	Switch("dryrun|dry"),
	Switch("force")
	);

my $opt = Getopt::Lucid->getopt(\@spec);

if ($opt->get_help) {
	#print STDERR "gene_mutrate.pl --conf CONFIG [--wrk WRKDIR] --in INPUT -out OUTPUT\n";
	print STDERR <<EOF;
Purpose:
	This is a pipeline script to generate PopScore lookup table for a given pathogenicity score. 

Note:
	The input file should be an annotated list of all possible SNVs in genes or exome, which can
	be generated by enum_cdssnvs pipeline. The pipeline requires input as a directory containing
	annotated SNVs for each gene. We will make use of two fields from each annotation file: 
	one is pathogenicty prediction (e.g. CADD), the other is population allele frequency (e.g. gnomAD exomes).

	We implemented PSAP's method to simulate genotypes in the population based on population
	allele frequency in ExAC or gnomAD. Then pop score is the p-value of observing the genotype (het, comp het or hom)
	of a variant that are as extreme as or more extreme than each cutoff of pathogenicity prediction score.

	Ref: Wilfert AB 2017 Genomewide significance testing of variation from single case exomes.
	Nat Genet. 2016 Dec; 48(12): 1455â€“1461.

EOF
	exit 1;
}

$opt->validate({ requires => [qw|conf outdir|] });


my %conf = merge_conf($opt->get_conf, $opt->get_param); 

if ($opt->get_indir) {
	$conf{Input}{Directory} = $opt->get_indir;
}
my $indir = $conf{Input}{Directory};
$conf{PATH} = { UTILDIR => "$Bin/utils", INDIR => abs_path($indir) };

lock_hash_recurse(%conf);

unless(-d $indir) {
	die "Input must be a directory of annotated variant tables!";
}

my @vartabs = grep { !/^\./ && -f "$indir/$_" } IO::Dir->new($indir)->read();
printf STDERR "A total of %d annotated variant tables can be found in %s\n", scalar(@vartabs), $indir;


#############################
## Input files preparation ##
#############################

my $rootdir = $opt->get_outdir;

my $wkf = Utils::Workflow->new($rootdir,
	{ engine => $opt->get_engine, force => $opt->get_force });

for(my $ii = 0; $ii < @vartabs; $ii ++) {
	my $jj = $ii + 1;
	open my $fout, ">$rootdir/par/DATA.$jj" or die "Cannot write to DATA.$jj";
	print $fout $vartabs[$ii], "\n";
}

write_config %conf, "$rootdir/par/run.conf";

$wkf->add(sim_popscores(), { name => "SimPopScores", nslots => scalar(@vartabs),
							  expect => [ map { "wrk/$_.txt" } @vartabs ] })
	->add(collect_res(), { name => "CollectRes", depend => "SimPopScores", interp => "perl",
						   expect => "out/PopScores.txt", callback => \&check_res });

$wkf->inst(\%conf);
$wkf->run({ conf => $conf{$wkf->{engine}}, dryrun => $opt->get_dryrun });


############################
## Workflow components    ##
############################

sub sim_popscores {
	my $script = <<'EOF';

read VARTAB < _PARDIR_/DATA._INDEX_

perl _PATH.UTILDIR_/simu_popscores.pl --in _PATH.INDIR_/$VARTAB --out _WRKDIR_/$VARTAB.txt --conf _PARDIR_/run.conf 

EOF
}

sub collect_res {
	my $script = <<'EOF';
use strict;
use warnings;
use IO::Dir;

my @vartabs = grep { !/^\./ && -f "_PATH.INDIR_/$_" } IO::Dir->new("_PATH.INDIR_")->read();

open my $fout, ">_OUTDIR_/PopScores.txt" or die "Cannot write to _OUTDIR_/PopScores.txt";
for(my $ii = 0; $ii < @vartabs; $ii ++) {
	unless(-f "_WRKDIR_/$vartabs[$ii].txt") {
		die "Cannot find split $ii output $vartabs[$ii] in the working directory";
	}
	open my $fin, "_WRKDIR_/$vartabs[$ii].txt" or die "Cannot open $vartabs[$ii]";
	<$fin> if $ii > 0;
	while(<$fin>) {
		print $fout $_;
	}
}

EOF
}

sub check_res {
	my ($outfile) = @_;
	if (-f "$rootdir/$outfile") {
		my $n_line = count_line("$rootdir/$outfile");
		if ($n_line == scalar(@vartabs) + 1) {
			return 1;
		}
		else {
			return 0;
		}
	}
	else {
		return 0;
	}
}



