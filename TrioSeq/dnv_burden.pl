#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use IO::Dir;
use IO::File;
use Perl6::Slurp;
use Data::Dumper;
use FindBin qw|$Bin|;
use List::Util qw|min max|;
use List::MoreUtils qw|all any uniq|;
use Getopt::Lucid qw|:all|; 
use Statistics::R;
use Config::Std;
use Graph::Undirected;
use Hash::Util qw|lock_keys|;
use Utils::Parser qw|sql_query|;
use Utils::Hash qw|chk_default str2hash|;
use Utils::File::Iter qw|iter_file slurp_file|;
use Genome::UCSC qw|hg_par|;
use Genome::UCSC::GeneTable qw|iter_geneTab iter_genePred|;


use lib "$Bin/../lib";
use Variants qw|xfactor|;
use Shared qw|parse_filters parse_tabfile read_geneset read_twinsibs read_sibgraph parse_fstr slurp_xref expand_dat|;


my @spec =  (
	Param("input|in|i"),
	Param("output|out|o"),
	Param("conf|c")->valid(sub { -r }),
	Switch("help|h")
	);

my $opt = Getopt::Lucid->getopt(\@spec);

if ($opt->get_help) {
	print STDERR <<EOF;
Purpose:
	This is a standalone script to evaluate the burden of DNVs in different gene sets and sub-groups of 
	samples by comparing to the baseline mutation rates or betweeen sub-groups.

Usage:
	dnv_burden.pl [--in VarTable] --conf Config --out Prefix 

Options:
	--in: Input variant table. It overrides the variant table defined in the config.
	--out: Output file name prefix. If not provided, it will be same as prefix of config file.

Notes:
	DNV burden is evaluated by comparing the observed number of DNVs of a variant class in some gene set
	from a group of samples to the theoretical expectation predicted by the baseline mutation rates and
	sample size. Baseline mutation rates can be calculated for different variant classes in the each gene
	using several mutation models (implemented in gene_mutrate.pl) and optionally adjusted for depth of coverage
	(callable_merge.pl). When the baseline mutation rate is not available, burden can also be evaluated by 
	comparing DNV rates between different sample groups. One-sided Poisson test is used in these comparisons.
	
	We have dealt with several special cases:
	* MZ twins or duplicated sample with different IDs will be treated as one sample in they are in the same group
	* Shared DNV between twins or sibs are treated as the same mutational event
	* Multiple nearby variants (defined by a distance cutoff in the config) are considered same mutational events, 
	  and only one with most severe effects will be selected in the analysis. The severity of variant classes are
	  defined by the order they appear in the config.  
	* Mutation rates on chrX is sex depenent because male offspring it is the mutation rate in mother's germline only.
	  We scale the chrX rate to account for difference in mutation rates between spermatogenesis and oogenesis.
	* Because of overlapping genes, in rare cases one mutation can be annotated to multiple different genes.
	  It can be minimized by excluding read-through genes. But if it happens, it contribute counts to multiple genes.

Input/output:
	The input files to the burden analysis are defined in the config. They should include: one or more variant tables 
	(generated by anno_seqvars.pl), a gene-specific haploid mutation rate table for different classes of variants 
	(genereated by gene_mutrate.pl), and one or more sample tables including phenotype, sex and other sample level 
	information. Variant classes, sample groups, and gene sets are defined in the config file.

	The following files will be appear in the output:

 	* prefix.burden.txt -- Summary of the burden w.r.t baseline mutation rates of different variant class in different sample 
 							groups and gene sets
	* prefix.contra.txt --  Comparison of burdens between different sample groups and by gene set and variant class 
							if contrasting groups are defined.
	* prefix.sampsize.txt -- Summary of all/male/female sample sizes for different sample groups 
	* prefix.genetab.txt -- Table of variant counts and mutation rate in each gene for selected sample groups and variant class
 						 	This table can be used as the input for downstream gene-based analysis.
 	* prefix.samptab.txt -- Table of the number of observed variants in differnet gene sets and variant classes per sample.
 							This table includes all samples passed filter and inclusion/exclusion list, the results can be used
 							to correlate mutational burden with phenotypes. 
 	* prefix.varrm.txt -- List of variants removed from the analysis due to nearby variant cluster.
 						  It will only include variants on samples included in the analysis.

EOF
	exit 1;
}

$opt->validate({ requires => [qw|conf|] });


read_config $opt->get_conf => my %conf;
# If input is provided, we will over-ride the VarTab in config
if ($opt->get_input) {
	$conf{Variant}{Table} = $opt->get_input;
	unless(-f $conf{Variant}{Table}) {
		die "Cannot find variant table: $conf{Variant}{Table}";
	}
}

lock_keys(%conf);

my $output;
if($opt->get_output) {
	$output = $opt->get_output;
}
else {
	$output = $opt->get_conf;
	$output =~ s/\.conf$//;
}
if ($output =~ /\.txt$/) {
	$output =~ s/\.txt$//;
}

#
# Sample Information
#
# Find out sample sizes and male/female proportion for each sub-groups if defined
my (@sampgroup, %sampgroup, %sampsize, %sampincl, %samprm, %twinsibs, @gpairs);
# @sampgroup is an array of sample groups defined in config
# %sampgroup is a hash of hash to hold group membership of each sample $sampgroup{IID}{Group} = 1
# %sampsize stores total/male/female sample size for each sample group $sampsize{Group}{M} = Count, 
#    	-- sex-specific sample sizes are necessary for calculating baseline mutation rate in chrX
# %samprm is a hash of sample IDs to be removed from the analysis.
# If sample table is not provided, only one group "All" will be used, and sample size must be specified.
# Note: unlike gene set, no default group "All" will be used unless it is explicitly defined.
# If sample table is provided, sample groups are defined from filtering expressions specified in config
# %twinsibs is a hash of array ref, keep track of all twin or sibs to each child
# If a pair of twin or sib appear in the same group, the shared mutation will not double counted.
# Because we keep track of all DNVs, when the same DNVs is shared by a sib/twin pair from same
# group, it only add count 1 to that group. 
# @gpairs is a list of group pairs used for direct comparison
{
	if (defined $conf{Sample}{Exclude}) {
		unless(ref $conf{Sample}{Exclude}) {
			$conf{Sample}{Exclude} = [$conf{Sample}{Exclude}];
		}
		foreach my $excllist (@{$conf{Sample}{Exclude}}) {
			unless (-f $excllist) {
				die "Cannot find bad sample list $excllist";
			}
			print STDERR "Reading sample exclusion list from $excllist\n";
			#%samprm = map { (split)[0] => 1 } slurp $excllist;
			open my $fin, $excllist or die "Cannot open $excllist";
			while(<$fin>) {
				my $gid = (split)[0];
				$samprm{$gid} = 1;
			}
		}
	}
	if (defined $conf{Sample}{Include}) {
		unless (-f $conf{Sample}{Include}) {
			die "Cannot find good sample list $conf{Sample}{Include}";
		}
		print STDERR "Reading sample inclusion list from $conf{Sample}{Include}\n";
		%sampincl = map { (split)[0] => 1 } slurp $conf{Sample}{Include};
	}

	my (@samptabs, $f_iid, $f_sex);
	$f_sex = $conf{Sample}{Sex};
	if (defined $conf{Sample}{Table}) {
		if (ref $conf{Sample}{Table} eq 'ARRAY') {
			@samptabs = @{$conf{Sample}{Table}};
		}
		else {
			@samptabs = ($conf{Sample}{Table});
		}
		$f_iid = $conf{Sample}{SampID};
	}
	else {
		# Note: when gathering sample info from variant table, no variant filter will be applied
		print STDERR "Gather sample info from variant table\n";
		if (ref $conf{Variant}{Table} eq 'ARRAY') {
			@samptabs = @{$conf{Variant}{Table}};
		}
		else {
			@samptabs = ($conf{Variant}{Table});
		}
		$f_iid = $conf{Variant}{SampID};
	}
	unless(all { -f $_ } @samptabs) {
		die "Not all sample table files exist";
	}

	my $filter;
	if (exists $conf{Sample}{Filter}) {
		my $filtexpr = $conf{Sample}{Filter};
		$filtexpr =~ s/^["']//; $filtexpr =~ s/["']$//;
		($filter, my $tokens) = sql_query($filtexpr, 1);
		foreach my $samptab (@samptabs) {
			my ($it, $fnames) = iter_file($samptab, { fsep => qr/\t/ });
			foreach my $tok (@$tokens) {
				if ($tok->[0] eq 'FIELD') {
					unless(grep { $tok->[1] eq $_} @$fnames) {
						die "Cannot find Filter field $tok->[1] in sample table $samptab";
					}
				}
			}
		}
	}

	# Parse and validate sample group filters	
	my $callbacks;
	if (defined $conf{Sample}{Group}) {
		(my $samptypes, $callbacks, my $fields) = 
			parse_filters($conf{Sample}{Group}, $conf{Sample}{Group_Filter});
		foreach my $samptab (@samptabs) {
			my ($it, $fnames) = iter_file($samptab, { fsep => qr/\t/ });
			foreach my $field (keys %$fields) {
				unless(grep { $field eq $_ } @$fnames) {
					die "Cannot find field $field from sample table";
				}
			}
			unless(grep { $f_iid eq $_ } @$fnames) {
				die "Cannot find sample ID field $f_iid from sample table";
			}
			if (defined $f_sex) {
				unless(grep { $f_sex eq $_ } @$fnames) {
					die "Cannot find sample sex field $f_sex from sample table";
				}
			}
			else {
				unless($conf{Sample}{AllowNoSex} =~ /^Y/ && defined $conf{Sample}{PMale}) {
					die "Must allow no sex and provide male proportion when sample sex info is not available";
				}
			}
		}
		@sampgroup = @$samptypes;
		# Init sample sizes
		foreach my $sgroup (@sampgroup) {
			$sampsize{$sgroup}{ALL} = $sampsize{$sgroup}{M} = $sampsize{$sgroup}{F} = 0;
		}
	}
	else {
		unless(defined $conf{Sample}{Size}) {
			die "Must provide sample size when sample group is not defined";
		}
		unless($conf{Sample}{Size} =~ /^\d+$/) {
			die "Sample size for all must be a single integer!";
		}
		# When no sample group is defined, we will create an "All" group for all samples
		@sampgroup = qw|All|;
		# Set full sample size to the pre-specified 
		$sampsize{All}{ALL} = $conf{Sample}{Size};
		# Then set male/female sample sizes based on PMale
		unless($conf{Sample}{AllowNoSex} =~ /^Y/ && defined $conf{Sample}{PMale}) {
			die "Must allow no sex and provide male proportion when sample group is not defined";
		}
		unless($conf{Sample}{PMale} >= 0 && $conf{Sample}{PMale} <= 1) {
			die "Incorrect proportion of males: $conf{Sample}{PMale}";
		}
		$sampsize{All}{M} = int($sampsize{All}{ALL} * $conf{Sample}{PMale} + 0.5);
		$sampsize{All}{F} = $sampsize{All}{ALL} - $sampsize{All}{M};
	}

	# Parse sample table to get sample size for each subgroup and group memberships 
	# Should also need to check no sample overlap among different sample tables
	my ($sampct, %known, %knowntabs, %sampsex);	
	foreach my $samptab (@samptabs) {
		my ($it, $fnames) = iter_file($samptab, { fsep => qr/\t/ });
		while(my $dat = $it->()) {
			my $iid = $dat->{$f_iid};
			if (defined $filter) {
				# Sample failed sample-filter will be added to removal list
				unless ($filter->($dat)) {
					$samprm{$iid} = 1;
					next;
				}
			}
			if (%sampincl) {
				next unless defined $sampincl{$iid};
			}
			next if defined $samprm{$iid};
			if (defined $known{$iid}) {
				if (defined $conf{Sample}{Table}) {
					die "Sample $iid has already appeared in the sample table previously";
				}
				else {
					if (defined $knowntabs{$iid} && $knowntabs{$iid} ne $samptab) {
						warn "Sample $iid has appeared in some previous variant table";
					}
					next;
				}
			}
			my $sex;
			if (defined $f_sex) {
				if ($dat->{$f_sex} =~ /^M/i) {
					$sex = 'M';
					$sampsex{$iid} = 'M';
				}
				elsif ($dat->{$f_sex} =~ /^F/i) {
					$sex = 'F';
					$sampsex{$iid} = 'F';
				}
				else {
					unless($conf{Sample}{AllowNoSex} =~ /^(Y|T)/) {
						die "Cannot determine sex for $iid";
					}
					else {
						warn "Cannot determine sex for $iid: $dat->{$f_sex}";
					}
				}
			}
			if($callbacks) {
				for(my $ii = 0; $ii < @sampgroup; $ii ++) {
					if ($callbacks->[$ii]->($dat)) {
						$sampgroup{$iid}{$sampgroup[$ii]} = 1;
						$sampsize{$sampgroup[$ii]}{ALL} ++;
						$sampsize{$sampgroup[$ii]}{$sex} ++ if defined $sex;
					}
				}
			}
			$known{$iid} = 1;
			$knowntabs{$iid} = $samptab;
			$sampct ++;
		}
	}
	print STDERR "A total of $sampct samples are found in sample table.\n";

	# Now validate sample size for each group
	if (defined $conf{Sample}{Size}) {
		my $sz;
		if ($conf{Sample}{Size} =~ /^\d+$/) {
			$sz = $conf{Sample}{Size};
			if (defined $conf{Sample}{Table}) {
				unless ($sz == $sampct) {
					die "Inconsistent sample size, $sampct found in sample table <> $sz specified in config";
				}
			}
			else {
				if($sampct > $sz) {
					die "Num of samples ($sampct) found in variant table > $sz specified in config";
				}
				elsif ($sampct < $sz) {
					warn "Num of samples ($sampct) found in variant table < $sz specified in config";
					if (@sampgroup > 1) {
						warn "You need to check consistency of sample sizes for other sample groups!";
					}
				}
			}
		}
		else {
			$sz = str2hash($conf{Sample}{Size}, { psep => ',', kvsep => ':' });
			foreach my $sgroup (@sampgroup) {
				unless(defined $sz->{$sgroup}) {
					die "Cannot find sample size for group $sgroup from sample size spec from config!";
				}
				if (defined $conf{Sample}{Table}) {
					unless ($sampsize{$sgroup}{ALL} == $sz->{$sgroup}{ALL}) {
						die "Inconsistent sample size for group $sgroup, $sampsize{$sgroup}{ALL} <> $sz->{$sgroup} specified in config";
					}
				}
				else {
					if ($sampsize{$sgroup}{ALL} > $sz->{$sgroup}) {
						die "Num of samples for group $sgroup ($sampsize{$sgroup}{ALL}) found in variant table > $sz->{$sgroup} specified in config";
					}
					elsif ($sampsize{$sgroup}{ALL} < $sz->{$sgroup}) {
						warn "Num of samples for group $sgroup ($sampsize{$sgroup}{ALL}) found in variant table < $sz->{$sgroup} specified in config";
						$sampsize{$sgroup}{ALL} = $sz->{$sgroup};
						if (@sampgroup > 1) {
							warn "You need to check consistency of sample size for other sample groups!";
						}
					}
				}
			}
		}
	}

	# Read twin/sib pairs
	if (defined $conf{Sample}{Twins} || defined $conf{Sample}{Sibs}) {
		%twinsibs = read_twinsibs($conf{Sample}{Twins}, $conf{Sample}{Sibs});
	}
	# Adjusting sample sizes in the presence of MZ twins
	# In case of triplet dup (A, B, C), we can include A,B and A,C in the twin pairs list
	# but not B,C! -- We need a better method for adjusting sample size for twins/dups!
	if (defined $conf{Sample}{Twins}) {
		print STDERR "Adjusting sample counts for MZ twins in all groups\n";
		#my %twins;
		#open my $fin, $conf{Sample}{Twins} or die "Cannot open twin pairs list: $conf{Sample}{Twins}";
		#while(<$fin>) {
		#	my @pair = split;
		#	unless(@pair == 2) {
		#		die "Incorrect line in twin pairs list: $_";
		#	}
		#	next if $twins{$pair[0],$pair[1]};
		#	$twins{$pair[0],$pair[1]} = 1;
		#	$twins{$pair[1],$pair[0]} = 1;
			# If both twins exist in the same group, minus one from the current count
			# Also need to account for the situation when sample group are not defined!
		#	foreach my $group (@sampgroup) {
		#		if(defined $sampgroup{$pair[0]}{$group} && defined $sampgroup{$pair[1]}{$group}) {
		#			#delete $sampgroup{$pair[1]}{$group};
		#			$sampsize{$group}{ALL} -= 1;
		#			if (defined $sampsex{$pair[1]}) {
		#				$sampsize{$group}{$sampsex{$pair[1]}} -= 1;
		#			}
		#		}
		#	}
		#}
		my $g = read_sibgraph($conf{Sample}{Twins});
		my @ccs = $g->connected_components();
		unless(all { scalar(@$_) >= 2 } @ccs) {
			die "Incorrect number of samples in connected twin/dup clusters!";
		}
		unless(defined $conf{Sample}{Group}) {
			unless (@sampgroup == 1 && $sampgroup[0] eq 'All') {
				print Dumper \@sampgroup;
				die "When sample group definition is not provided, should contain only one group!";
			}
		}

		# For each twin/dup cluster we will adjust the sample size for each group separately
		foreach my $cc (@ccs) {
			my @twindups = sort @$cc;
			if (defined $conf{Sample}{Group}) {
				foreach my $group (@sampgroup) {
					# See how many twin/dups are in the same group	
					my @samegrp = grep { defined $sampgroup{$_}{$group} } @twindups;
					next unless @samegrp > 1;
					for (my $ii = 1; $ii < @samegrp; $ii ++) {
						$sampsize{$group}{ALL} -= 1;
						if (defined $sampsex{$samegrp[$ii]}) {
							$sampsize{$group}{$sampsex{$samegrp[$ii]}} -= 1;
						}
					}
				}
			}
			else {
				for(my $ii = 1; $ii < @twindups; $ii ++) {
					$sampsize{All}{ALL} -= 1;
					if (defined $sampsex{$twindups[$ii]}) {
						$sampsize{All}{$sampsex{$twindups[$ii]}} -= 1;
					}
				}
			}
		}
	}

	# Then check if we need to adjust male/female sample sizes
	foreach my $type (@sampgroup) {
		unless ($sampsize{$type}{ALL} > 0) {
			die "No sample in group $type was found";
		}
		if ($sampsize{$type}{ALL} != $sampsize{$type}{F} + $sampsize{$type}{M}) {
			print STDERR "Imputing male/female sample sizes for $type";
			my $pm;
			my $den = $sampsize{$type}{F} + $sampsize{$type}{M};
			if ($den == 0) {
				unless($conf{Sample}{PMale}) {
					die "Cannot determine number of male/female samples for subtype $type";
				}
				unless($conf{Sample}{PMale} >= 0 && $conf{Sample}{PMale} <= 1) {
					die "Incorrect proportion of males: $conf{Sample}{PMale}";
				}
				$pm = $conf{Sample}{PMale};
			}
			else {
				$pm = $sampsize{$type}{M}/$den;
			}
			$sampsize{$type}{M} = int($sampsize{$type}{ALL}*$pm);
			$sampsize{$type}{F} = $sampsize{$type}{ALL} - $sampsize{$type}{M};
		}
	}

	# Group pairs for comparison
	if (defined $conf{Sample}{Compare}) {
		if (ref $conf{Sample}{Compare} eq 'ARRAY') {
			foreach my $comp (@{$conf{Sample}{Compare}}) {
				push @gpairs => map { [ split(':') ] } split(',', $comp);
			}
		}
		else {
			@gpairs = map { [ split(':') ] } split(',', $conf{Sample}{Compare});
		}
		foreach my $gpair (@gpairs) {
			my @groups = @$gpair;
			unless(@groups == 2 && (grep { $groups[0] eq $_ } @sampgroup) && 
								   (grep { $groups[1] eq $_ } @sampgroup)) {
				die "Cannot find comparison pair @{[ join(q|,|, @groups) ]} from sample groups";
			}
		}
		# Check that there is no sample overlap in contrasting group pairs
		foreach my $iid (keys %sampgroup) {
			foreach my $gpair (@gpairs) {
				if (defined $sampgroup{$iid}{$gpair->[0]} && defined $sampgroup{$iid}{$gpair->[1]}) {
					die "Sample $iid belongs to both constrasting groups: ".join(",", @$gpair);
				}
			}
		}
	}
}

#
# Variant classes
#
# Parse the variant class information from Variant specification
# They will be ordered from the most to the least severe consequences defined by the order of appearance
# in the config file
# 
my (@varclass, @varclswogene, @modifier, %varclass, %varrm, %varexcl);
# @varclass: is an array of variant classes defined in config by the order of appearance
# @varclswogene: is an array of variant classes that are not associated with genes
# @modifier: specify the way to define variant class when in case of overlapping genes.
# %varclass: is a hash to hold class membership of each variant in each gene $varclass{VarID}{GeneID}{Class} = 1
# Note: At this stage we keep all gene-specific annotations for each variant. It is possible to have
# 		multiple classes associated with one variant.
# %varrm: for nearby variants in the same individual, we will keep only one with most severe effect
# 		  the remaining variants will be removed from the analysis: $varrm{IID,VarID}{GeneID} = 1
# 		  It indicates the VarID in IID should be removed from GeneID for analysis.
# 		  GeneID can be "." for variants that are not associated with genes.
# Note: this account for the rare situation when VarID was annotated to Gene1 and Gene2, and removed
# from Gene1 but not from Gene2.
# %varexcl: variants to be excluded from analysis, can be sample-specific.
{
	# First parse the filtering expression to define each class of variants
	my ($varcls, $filters, $fields) = parse_filters($conf{Variant}{Class}, $conf{Variant}{Class_Filter});

	my %priority;
	my %valid = (All => 1, Any => 1, First => 1);
	foreach my $vclass (@$varcls) {
		my ($class, $modifier) = split(':', $vclass);
		unless(defined $modifier) {
			die "Cannot find modifier $vclass";
		}
		unless(defined $valid{$modifier}) {
			die "Cannot recognize modifier $modifier";
		}
		push @varclass, $class;
		push @modifier, $modifier;
		$priority{$class} = scalar(@varclass);
	}

	if (defined $conf{Variant}{ClassWoGene}) {
		foreach my $vclass (split(',', $conf{Variant}{ClassWoGene})) {
			unless(grep { $vclass eq $_ } @varclass) {
				die "Cannot find class without gene $vclass in original variant class definition";
			}
			push @varclswogene, $vclass;
		}
	}

	# If variant table level QC filter is defined, parse the filter
	# the filtered variants will be added to exclusion list
	my ($qcfilter, $tokens);
	if (exists $conf{Variant}{Filter}) {
		my $filtexpr = $conf{Variant}{Filter};
		$filtexpr =~ s/^["']//; $filtexpr =~ s/["']$//;
		($qcfilter, $tokens) = sql_query($filtexpr, 1);
	}

	# Slurp varaint exclusion list
	if (exists $conf{Variant}{Exclude}) {
		unless (ref $conf{Variant}{Exclude}) {
			$conf{Variant}{Exclude} = [$conf{Variant}{Exclude}];
		}
		foreach my $excllist (@{$conf{Variant}{Exclude}}) {
			open my $fin, $excllist or die "Cannot open $excllist";
			while(<$fin>) {
				my ($varid, $iid) = split;
				unless($varid =~ /^\w+\:\d+\:[ACGT]+\:[ACGT]+$/) {
					die "Incorrect variant ID: $varid";
				}
				if (defined $iid) {
					$varexcl{$iid,$varid} = 1;
				}
				else {
					$varexcl{$varid} = 1;
				}
			}
		}		
	}

	# It is possible to have multiple variant tables, they should be parsed by the same filters
	my @vartabs;
	if (ref $conf{Variant}{Table} eq 'ARRAY') {
		@vartabs = @{$conf{Variant}{Table}};
	}
	else {
		@vartabs = ($conf{Variant}{Table});
	}

	# Check that all fields in the filter exist in all variant tables
	my $f_iid = $conf{Variant}{SampID};
	foreach my $vartab (@vartabs) {
		my ($it, $fnames) = iter_file($vartab, { fsep => qr/\t/ });
		my @fields = qw|Chrom Position Ref Alt GeneID|;
		push @fields => $f_iid;
		push @fields, sort keys %$fields;
		foreach my $fd (@fields) {
			unless (grep { $fd eq $_ } @$fnames) {
				die "Cannot find field $fd from input variant table";
			}
		}
		if (defined $qcfilter) {
			foreach my $tok (@$tokens) {
				if ($tok->[0] eq 'FIELD') {
					unless(grep { $tok->[1] eq $_ } @$fnames) {
						die "Cannot find QC filter field $tok->[1] in variant table $vartab";
					}
				}
			}
		}
	}

	# Parse variant tables to keep track of class for each variant for future analysis
	# Also add nearby variants carried by the same individual into gene var graph;
	# which will be used later to determine the sentinel variant
	my %genevars;
	my $varbk = Genome::UCSC::BinKeeper->new();
	my (%known, %noclass);
	foreach my $vartab (@vartabs) {
		print STDERR "Parsing variant table $vartab\n";
		my ($it, $fnames) = iter_file($vartab, { fsep => qr/\t/ });
		while(my $dat = $it->()) {
			my $iid = $dat->{$f_iid};
			if (%sampincl) {
				next unless defined $sampincl{$iid};
			}
			next if defined $samprm{$iid};

			if (defined $conf{Sample}{Group}) {
				# When sample group definitions are provided, it is required that all samples appeared in 
				# the varinat table (after removing bad samples) be listed in the sample table!
				unless(defined $sampgroup{$iid}) {
					die "Cannot find sample group for $iid in $vartab";
					#next;
				}
			}
			else {
				# If no sample group definition is provided, all samples found in the variant table will be added
				# to "All" group by default
				$sampgroup{$iid}{All} = 1;
			}
			
			my $varid = join(":", @{$dat}{qw|Chrom Position Ref Alt|});
			if (defined $qcfilter) {
				unless($qcfilter->($dat)) {
					$varexcl{$iid,$varid} = 1;
				}
			}
			if (%varexcl) {
				next if defined $varexcl{$iid,$varid} || defined $varexcl{$varid};
			}

			if (defined $known{$iid,$varid}) {
				#warn "Duplicated variant found in the variant table $vartab: $iid,$varid";
				next;
			}
			$known{$iid,$varid} = 1;
			# Go through each gene-variant combination
			# Note it is possible for one variant to be associated with multiple classes
			# Note also that %varclass hash will only keep variant information, and we assume
			# the same variant from different sample should the same annotation
			my @data = expand_dat($dat, { sep => ';', optional => ["GeneID", keys %$fields] });
			my $prevclass;
			if (defined $varclass{$varid}) {
				$prevclass = join(",", map { "$_:$varclass{$varid}{$_}" } sort keys %{$varclass{$varid}});
			}
			else {
				$prevclass = "NA" if defined $noclass{$varid}; 
			}
			my $flag;
			foreach my $data (@data) {
				for(my $ii = 0; $ii < @varclass; $ii ++) {
					if ($filters->[$ii]->($data)) {
						# For variant class not associated to any gene, use dot as gene name
						if (grep { $varclass[$ii] eq $_ } @varclswogene) {
							$varclass{$varid}{'.'}{$varclass[$ii]} = 1;
						}
						else {
							$varclass{$varid}{$data->{GeneID}}{$varclass[$ii]} = 1;
						}
						$flag = 1;
					}
				}	
			}
			unless($flag) {
				if (defined $prevclass && $prevclass ne 'NA') {
					die "The variant $varid has different classifications: $prevclass => NA";
				}
				$noclass{$varid} = 1; # record and skip variants that cannot be classified
				next;
			}
			if (defined $prevclass) {
				my $currclass =  join(",", map { "$_:$varclass{$varid}{$_}" } sort keys %{$varclass{$varid}});
				if ($prevclass ne $currclass) {
					die "The variant $varid has different classifications: $prevclass => $currclass";
				}				
			}

			# Check if nearby classified variants in the same gene from the same individual exist
			foreach my $gene (sort keys %{$varclass{$varid}}) {
				my @overlaps = map { $_->[2][1] } grep { $iid.$;.$gene eq $_->[2][0] }
						$varbk->find_range($dat->{Chrom}, $dat->{Position}-$conf{Variant}{DistCutoff}, 
							$dat->{Position}+length($dat->{Ref})-1+$conf{Variant}{DistCutoff});
				if (@overlaps) {
					unless (defined $genevars{$iid,$gene}) {
						$genevars{$iid,$gene} = Graph::Undirected->new();
					}
					foreach my $nearvar (@overlaps) {
						$genevars{$iid,$gene}->add_edge($nearvar, $varid);
					}
				}
				$varbk->add($dat->{Chrom}, $dat->{Position}, $dat->{Position}+length($dat->{Ref})-1, 
							[$iid.$;.$gene, $varid]);
			}
		}
	}

	# Now parse the variant cluster to find sentinel variant for each cluster
	# and put all other variants in the same cluster to the removal list.
	# Note: this variant graph does not remove duplicated variants!
	while(my ($giid, $graph) = each %genevars) {
		my ($iid, $gene) = split($;, $giid);
		foreach my $cc ($graph->connected_components()) {
			# find the sentinel variant
			my %rank;
			foreach my $varid (@$cc) {
				$rank{$varid} = min(map { $priority{$_} } keys %{$varclass{$varid}{$gene}});
			}
			my @ccsort = sort { $rank{$a} <=> $rank{$b} } @$cc;
			foreach my $othervar (@ccsort[1..$#ccsort]) {
				$varrm{$iid,$othervar}{$gene} = 1; 
			}
		}
	}
}


#
# Genes and mutation rates
#
my (%mutrate, @varclswrate, %geneXhap, %generm, %geneset, @geneset);
# We will collect the full gene list from mutation rate table, anything not in this table
# will not be included in the burden analysis.
#
# %mutrate is a hash of hash to store per-gene mutation rate $mutrate{GeneID}{VarClass} = rate
# Note: Not all variant class defined to parse variant table will have a baseline rate
# @varclswrate is the list of variant classes with baseline mutation rate, it can even be empty, in this case
# we will not compare the count with baseline mutation rate.
#
# %geneXhap will indicate if a gene is located on the haploid part of chrX; this information will be fetched from UCSC gene table.
# %generm will keep track of blacklist genes to be removed from the analysis
# Note: genes without baseline mutation rate or genes showning up in the blacklist will not be included from the full set.
#
# %genesets is a hash of hash to hold geneset membership for each gene: $geneset{Set}{GeneID} = 1 (simiar to sampgroup)
# 			By default, each gene will also be assigned to an "All" set.
# @geneset is an array of all gene sets starting with the default "All".
{
	if (defined $conf{Gene}{Exclude}) {
		unless (ref $conf{Gene}{Exclude}) {
			$conf{Gene}{Exclude} = [$conf{Gene}{Exclude}];
		}
		foreach my $excllist (@{$conf{Gene}{Exclude}}) {
			unless(-f $excllist) {
				die "Cannot find gene exclusion list: $excllist";
			}
			#%generm = map { (split)[0] => 1 } slurp $excllist;
			open my $fin, $excllist or die "Cannot open $excllist";
			while(<$fin>) {
				my $gid = (split)[0];
				$generm{$gid} = 1;
			}
		}
	}
	# Variant classes that defined above and not included in the mutrate table will not be included
	# in baseline mutation rate comparison
	# Genes not included in the mutation rate table will not be included in tally variant counts for
	# variant classes that are associated with genes.
	# It is possible to not define any variant class from mutation rate table, in such cases
	# we only use this table to find "All" genes to be included in tally.
	my ($it, $fnames) = iter_file($conf{MutRate}{Table}, { fsep => qr/\t/ });
	my $f_gid = $conf{MutRate}{GeneID};
	unless(grep { $f_gid eq $_ } @$fnames) {
		die "Cannot find gene ID field $f_gid from mutation rate table";
	}

	my $varcls;
	if (defined $conf{MutRate}{VarClass}) {
		$varcls = parse_fstr($conf{MutRate}{VarClass}, 1);
		foreach my $class (keys %$varcls) {
			unless(grep { $_ eq $class } @varclass) {
				warn "Cannot find definition of variant class: $class!";
			}
			if (grep { $_ eq $class } @varclswogene) {
				die "Variant class $class is not associated with gene!";
			}
			my $colname = $varcls->{$class};
			if ($colname =~ /[*+]/) {
				my %coeff;
				my @terms = split('\+', $colname);
				foreach my $term (@terms) {
					my @spterm = split('\*', $term);
					if (@spterm == 1) {
						unless(grep { $spterm[0] eq $_ } @$fnames) {
							die "Cannot find field $spterm[0] in mutation rate table";
						}
						$coeff{$spterm[0]} = 1;
					}
					elsif (@spterm == 2) {
						unless($spterm[0] =~ /^[0-9\.]+$/) {
							die "Incorrect format of coefficient: $spterm[0]";
						}
						unless(grep { $spterm[1] eq $_ } @$fnames) {
							die "Cannot find field $spterm[1] in mutation rate table";
						}
						$coeff{$spterm[1]} = $spterm[0];
					}
					else {
						die "Cannot split fields to find coefficient and term";
					}
				}
				$varcls->{$class} = \%coeff;
			}
			else {
				unless (grep { $colname eq $_ } @$fnames) {
					die "Cannot find field $colname in mutation rate table!";
				}
			}
			push @varclswrate, $class;
		}
	}
	
	# Collect mutation rate for each class of variants for each gene
	while(my $dat = $it->()) {
		my $gid = $dat->{$f_gid};
		next if defined $generm{$gid};
		if (defined $mutrate{$gid}) {
			warn "Mutation rate for gene $gid has already been defined";
			next;
		}
		# All genes that appear in the mutation rate table will be assigned to the "All" set
		$geneset{All}{$gid} = 1;
		unless(defined $varcls) {
			$mutrate{$gid} = {};
			next;
		}
		foreach my $class (sort keys %$varcls) {
			my $colname = $varcls->{$class};

			if ($conf{MutRate}{log10} =~ /^Y/) {
				if (ref $colname) {
					my $rate = 0;
					foreach my $field (sort keys %$colname) {
						if ($dat->{$field} ne $conf{MutRate}{NAstring}) {
							$rate += 10**$dat->{$colname};
						}
					}
					if ($rate == 0) {
						$mutrate{$gid}{$class} = $conf{MutRate}{Zero};
					}
					else {
						$mutrate{$gid}{$class} = $rate;
					}
				}
				else {
					if ($dat->{$colname} eq $conf{MutRate}{NAstring}) {
						$mutrate{$gid}{$class} = $conf{MutRate}{Zero};
					}
					else {
						$mutrate{$gid}{$class} = 10**$dat->{$colname};
					}
				}
			}
			else {
				if (ref $colname) {
					my $rate = 0;
					foreach my $field (sort keys %$colname) {
						if ($dat->{$field} > 0) {
							$rate += $dat->{$field}*$colname->{$field};
						}
						else {
							if ($dat->{$field} < 0) {
								die "Mutation rate cannot be less than 0: $field = $dat->{$field}";
							}
						}
					}
					if ($rate == 0) {
						$mutrate{$gid}{$class} = $conf{MutRate}{Zero};	
					}
					else {
						$mutrate{$gid}{$class} = $rate;
					}
				}
				else {
					if ($dat->{$colname} > 0) {
						$mutrate{$gid}{$class} = $dat->{$colname};
					}
					elsif ($dat->{$colname} == 0) {
						# For mutation rate of zero, assign a value that is arbitrarily small
						$mutrate{$gid}{$class} = $conf{MutRate}{Zero};
					}
					else {
						die "Mutation rate cannot be less than 0: $colname = $dat->{$colname}";
					}
				}
			}
		}
	}
	# Lookup X hap genes
	my ($git, %hgpar, %nonhgchr);
	if (-f $conf{Gene}{DBTable}) {
		$git = iter_genePred($conf{Gene}{DBTable});

	}
	else {
		$git = iter_geneTab($conf{Gene}{HgBuild}, $conf{Gene}{DBTable});
	}
	while(my $dat = $git->()) {
		unless($dat->{chrom} =~ /^chr[0-9X]+$/) {
			$nonhgchr{$dat->{name2}} = 1;
			next;
		}
		unless($dat->{cdsStart} < $dat->{cdsEnd}) {
			next;
		}
		next if defined $hgpar{$dat->{name2}};
		$hgpar{$dat->{name2}} = hg_par($dat->{chrom}, int(0.5*($dat->{cdsStart}+$dat->{cdsEnd})),
									   $conf{Gene}{HgBuild});
	}
	# If inclusion list is provided, we can keep only those appear in the inclusion
	my %geneincl;
	if (defined $conf{Gene}{Include}) {
		%geneincl = map { (split)[0] => 1 } slurp $conf{Gene}{Include};
	}
	foreach my $gid (sort keys %mutrate) {
		if (defined $conf{Gene}{Include}) {
			unless(defined $geneincl{$gid}) {
				delete $mutrate{$gid};
				delete $geneset{All}{$gid};
				next;
			}
		}
		if (defined $nonhgchr{$gid}) {
			print STDERR "Removing non-hgchr gene $gid from mutrate table\n";
			delete $mutrate{$gid};
			delete $geneset{All}{$gid};
			next;
		}
		unless(defined $hgpar{$gid}) {
			die "Cannot find chromosome location for gene $gid from DBTable";
		}
		if (defined $hgpar{$gid} && $hgpar{$gid} > 0) {
			$geneXhap{$gid} = 1;
		}
	}
	# Store additional gene set membership
	@geneset = qw(All);
	# "All" set will not include "."!
	# $geneset{"."}{"."} = 1;
	if (defined $conf{Gene}{Set}) {
		my $gs = read_geneset($conf{Gene}{Set}, $conf{Gene}{Set_Fields});
		while(my ($set, $genes) = each %$gs) {
			if ($set eq 'All') {
				die "Gene set All is reserved!";
			}
			foreach my $gid (@$genes) {
				# Restrict to genes with mutation rate!
				next unless defined $mutrate{$gid};
				$geneset{$set}{$gid} = 1;
			}
		}
		push @geneset, sort grep { $_ ne 'All' } keys %geneset;
	}	
}

#
# Expected number of de novo coding variants
#
# Aggregate per-gene rate of different classes of variants to calculate expected number of variants
# in different groups of samples defined above.
my (%exprate, %expratebygene);
# %exprate will be a hash of hash to hold expected rates: exprate{SampGroup}{GeneSet}{VarClass} = Rate
# %expratebygene will be hash of hash to hold gene-specific rate after correcting for sample composition
# Calculate exprate only when baseline mutation rates are available.
if (@varclswrate) {
	# Going through all sample groups
	foreach my $sgroup (@sampgroup) {
		my $p_male = $sampsize{$sgroup}{M}/$sampsize{$sgroup}{ALL};
		my $x_factor = xfactor($p_male, $conf{MutRate}{Alpha});
		# Going through all variant class and gene sets defined above 
		foreach my $vclass (@varclswrate) {
			foreach my $gset (@geneset) {
				foreach my $gid (sort keys %{$geneset{$gset}}) {
					if ($geneXhap{$gid}) {
						$exprate{$sgroup}{$gset}{$vclass} += $x_factor * $mutrate{$gid}{$vclass};
					}
					else {
						unless(defined $mutrate{$gid}) {
							die "Cannot find mutation rate for $gid in gene set $gset";
						}
						$exprate{$sgroup}{$gset}{$vclass} += $mutrate{$gid}{$vclass};
					}
				}
			}
		}
		# Also going through each individual genes
		foreach my $vclass (@varclswrate) {
			foreach my $gid (sort keys %mutrate) {
				if ($geneXhap{$gid}) {
					$expratebygene{$sgroup}{$gid}{$vclass} = $x_factor * $mutrate{$gid}{$vclass};
				}
				else {
					$expratebygene{$sgroup}{$gid}{$vclass} = $mutrate{$gid}{$vclass};
				}
			}
		}
	}
}

#
# Tally observed number variants
#
# Tally the number of variants in different functional class and in different subsets of samples
# In order to account for sibs and twins, we need to keep track of all observed variants
# Variants shared by twins or sibs will only count once if the twin or sib pair are in the same group
my (%obsct, %obsctbygene, %obsctbysamp);
# %obsct will be hash of hash to hold observed counts: $obsct{SampGroup}{GeneSet}{VarClass} = Count
# %obsctbygene will be hash of hash to hold gene-specific counts: $obsctbygene{SampGroup}{Gene}{VarClass} = Count
# %obsctbysamp will be hash of hash to hold sample-specific counts: $obsctbysamp{IID}{GeneSet}{VarClass} = Count
{
	# Keep track of obbserved variant in each sample $obsvar{$iid,$varid} = 1
	my %obsvar;
	# It is possible to have multiple variant tables
	my @vartabs;
	if (ref $conf{Variant}{Table} eq 'ARRAY') {
		@vartabs = @{$conf{Variant}{Table}};
	}
	else {
		@vartabs = ($conf{Variant}{Table});
	}

	my $f_iid = $conf{Variant}{SampID};
	# Iterate through the mutation table, tally the counts in each gene set and sample group
	# We will skip samples and genes to be removed
	foreach my $vartab (@vartabs) {
		my ($it, $fnames) = iter_file($vartab, { fsep => qr/\t/ });
		
		while(my $dat = $it->()) {
			my $iid = $dat->{$f_iid};
			#next unless defined $sampgroup{$iid};
			if (%sampincl) {
				next unless defined $sampincl{$iid};
			}
			next if defined $samprm{$iid};
			my $varid = join(":", @{$dat}{qw|Chrom Position Ref Alt|});
			if (%varexcl) {
				next if defined $varexcl{$iid,$varid} || defined $varexcl{$varid};
			}

			if (defined $obsvar{$iid,$varid}) {
				warn "Duplicated variant found in the variant table $vartab: $iid,$varid";
				next;
			}
			# Keep track of all observed variants
			$obsvar{$iid,$varid} = 1;

			# If the sample is part of a twin or sib pair, and if the variant has been observed before in a sib/twin
			# of group A, then we will skip counting this variant in group A for gene or gene set
			my %grprm;
			if ($twinsibs{$iid}) {
				foreach my $sgroup (sort keys %{$sampgroup{$iid}}) {
					my @samegrp = grep { defined $sampgroup{$_} && defined $sampgroup{$_}{$sgroup} } @{$twinsibs{$iid}};
					if (any { defined $obsvar{$_,$varid}  } @samegrp) {
						$grprm{$sgroup} = 1;
					}
				}
			}

			# If a variant is not associated with any gene, then . should be used in GeneID column
			my @genes = grep { !defined $generm{$_} } split(';', $dat->{GeneID});
			if (defined $varrm{$iid,$varid}) {
				@genes = grep { !defined $varrm{$iid,$varid}{$_} } @genes;
			}
			next unless @genes > 0;

			# First add gene specific counts if genetab output is specified
			if (exists $conf{GeneTab}) {
				foreach my $gene (grep { $_ ne '.' } @genes) {
					my $classref = $varclass{$varid}{$gene};
					next unless defined $classref;
					foreach my $sgroup (sort keys %{$sampgroup{$iid}}) {
						next if $grprm{$sgroup};
						foreach my $vclass (sort keys %$classref) {
							if (grep { $vclass eq $_ } @varclswogene) {
								die "Variant class $vclass is not associated with any gene, and should not be included in gene table";
							}
							$obsctbygene{$sgroup}{$gene}{$vclass} ++;
						}
					}
				}
			}
			
			# Then add gene set specific counts, we first separately treat variant classes that are not associated with genes
			# Also add sample specific counts
			if (@varclswogene && !defined $varrm{$iid,$varid}{"."}) {
				for(my $ii = 0; $ii < @varclswogene; $ii ++) {
					my $vclass = $varclswogene[$ii];
					if (defined $varclass{$varid}{"."}{$vclass}) {
						$obsctbysamp{$iid}{"."}{$vclass} ++;
						foreach my $sgroup (sort keys %{$sampgroup{$iid}}) {
							next if $grprm{$sgroup};
							$obsct{$sgroup}{"."}{$vclass} ++;
						}
					}
				}
			}

			# Tally gene set specific counts
			# If a variant overlapping multiple genes, they will only have one variant class by the use of modifier
			# To account for the overlapping genes in the baseline, we can collect overlapping genes that
			# have the same annotations for variants, then keep only one with the highest mutation rate.
			# We did not implement this correction because the effects seems negligible, but we can also manually 
			# add one of the overlapping genes to the blacklist.
			foreach my $gset (@geneset) {
				my @genesinset = grep { defined $geneset{$gset}{$_} } @genes;
				# Be careful of using all, it evaluates to true for empty array!
				# So we should skip gene set that does not contain genes!
				next unless @genesinset > 0;
				my @vclass;
				for(my $ii = 0; $ii < @varclass; $ii ++) {
					next if grep { $varclass[$ii] eq $_ } @varclswogene;
					if ($modifier[$ii] eq 'All') {
						if (all { defined $varclass{$varid}{$_} && defined $varclass{$varid}{$_}{$varclass[$ii]} } @genesinset) {
							push @vclass => $varclass[$ii];
						}
					}
					elsif ($modifier[$ii] eq 'Any') {
						if (any { defined $varclass{$varid}{$_} && defined $varclass{$varid}{$_}{$varclass[$ii]} } @genesinset) {
							push @vclass => $varclass[$ii];
						}
					}
					elsif ($modifier[$ii] eq 'First') {
						if (defined $varclass{$varid}{$genesinset[0]} && defined $varclass{$varid}{$genesinset[0]}{$varclass[$ii]}) {
							push @vclass => $varclass[$ii];
						}
					}
					else {
						die "Cannot recognize modifier: $modifier[$ii]";
					}
				}
				next unless @vclass > 0;
				foreach my $vclass (@vclass) {
					$obsctbysamp{$iid}{$gset}{$vclass} ++;
				}
				foreach my $sgroup (sort keys %{$sampgroup{$iid}}) {
					# Do not double count same variants in twin or sibs
					next if $grprm{$sgroup};
					foreach my $vclass (@vclass) {
						$obsct{$sgroup}{$gset}{$vclass} ++;
					}
				}
			}
		}
	}
}

# 
# Scale the baseline mutation rate
# 
# Should provide a sample group and variant group for recalibration
# Or it can be a manually specified factor to multiply with the mutation rate
my $scalefactor;
if (defined $conf{MutRate}{Scale}) {
	if ($conf{MutRate}{Scale} =~ /^[0-9\.]+$/) {
		$scalefactor = $conf{MutRate}{Scale};
	}
	else {
		my ($sgroup, $vclass) = split(',', $conf{MutRate}{Scale});
		unless(defined $sgroup && defined $sampsize{$sgroup} &&
			   defined $vclass && (grep { $vclass eq $_ } @varclswrate)) {
			die "Must provide sample group and variant class (with mutrate) for scaling mutation rate";
		}
		$scalefactor = $obsct{$sgroup}{All}{$vclass}/($exprate{$sgroup}{All}{$vclass}*2*$sampsize{$sgroup}{ALL});
		print STDERR "Scaling factor for mutation rate = $scalefactor\n";
	}
}
else {
	$scalefactor = 1;
}

#
# Statistical test and Summary
#
my $R = Statistics::R->new();

# Summarize the observed count and rate in each gene set and variant class
# And compare with the expected count predicted by baseline mutation rate if available
open my $fout, ">$output.burden.txt" or die "Cannot write to $output.burden.txt";
print $fout join("\t", qw|SampleGroup N_Samps GeneSet N_Genes VarClass ObsCount ObsRate ExpCount ExpRate FoldOvsE P-value|), "\n";
foreach my $sgroup (@sampgroup) {
	foreach my $gset (@geneset) {
		foreach my $vclass (@varclass) {
			next if grep { $vclass eq $_ } @varclswogene;
			my $n_obs = $obsct{$sgroup}{$gset}{$vclass} // 0;
			my $r_obs = $n_obs / $sampsize{$sgroup}{ALL};
			my ($n_exp, $r_exp, $fold, $pval);
			if (grep { $vclass eq $_ } @varclswrate) {
				$r_exp = 2 * $exprate{$sgroup}{$gset}{$vclass} * $scalefactor;
				$n_exp = $r_exp * $sampsize{$sgroup}{ALL} ;
				if ($r_exp > 0) {
					$fold = sprintf("%.3f", $n_obs/$n_exp);
					$R->set('obs', $n_obs);
					$R->set('exp', $n_exp);
					$R->run('pval<-poisson.test(obs, exp, alternative="two.sided")$p.value');
					$pval = sprintf("%.2E", $R->get('pval'));
				}
				else {
					$fold = ".";
					$pval = ".";
				}
			}
			else {
				$r_exp = ".";
				$n_exp = ".";
				$fold = ".";
				$pval = ".";
			}
			print $fout join("\t",  $sgroup, $sampsize{$sgroup}{ALL}, $gset, scalar(keys %{$geneset{$gset}}), 
				$vclass, $n_obs, sprintf("%.4f", $r_obs), $n_exp eq '.' ? $n_exp : sprintf("%.1f", $n_exp), 
				$r_exp eq '.' ? $r_exp : sprintf("%.4f", $r_exp), $fold, $pval), "\n";
		}
	}
	if (@varclswogene) {
		foreach my $vclass (@varclswogene) {
			my $n_obs = $obsct{$sgroup}{"."}{$vclass} // 0;
			my $r_obs = $n_obs / $sampsize{$sgroup}{ALL};
			print $fout join("\t",  $sgroup, $sampsize{$sgroup}{ALL}, ".", ".", $vclass, 
									$n_obs, sprintf("%.4f", $r_obs), (".") x 4), "\n";
		}
	}
}



# Compare observed counts between different sample groups
if (@gpairs > 0) {
	open my $fcomp, ">$output.contra.txt" or die "Cannot write to $output.contra.txt";
	print $fcomp join("\t", qw|SampGroup1 N_Samps1 SampGroup2 N_Samps2 GeneSet N_Genes VarClass Count1 Rate1 Count2 Rate2 RateRatio P-value|), "\n";
	foreach my $gpair (@gpairs) {
		my @groups = @$gpair;
		# We will compare the observed rate per group
		foreach my $gset (@geneset) {
			foreach my $vclass (@varclass) {
				my $n_obs1 = $obsct{$groups[0]}{$gset}{$vclass} // 0;
				my $r_obs1 = $n_obs1 / $sampsize{$groups[0]}{ALL};
				my $n_obs2 = $obsct{$groups[1]}{$gset}{$vclass} // 0;
				my $r_obs2 = $n_obs2 / $sampsize{$groups[1]}{ALL};
				my ($ratio, $pval);
				if ($r_obs2 > 0) {
					$ratio = sprintf("%.3f", $r_obs1/$r_obs2);
					$R->set('x', $n_obs1);
					$R->set('n', $n_obs1+$n_obs2);
					$R->set('p', $sampsize{$groups[0]}{ALL}/($sampsize{$groups[0]}{ALL} + $sampsize{$groups[1]}{ALL}));
					$R->run('pval<-binom.test(x, n, p, alternative="two.sided")$p.value');
					$pval = sprintf("%.2E", $R->get('pval'));
				}
				else {
					$ratio = ".";
					$pval = ".";
				}
				print $fcomp join("\t", $groups[0], $sampsize{$groups[0]}{ALL}, $groups[1], $sampsize{$groups[1]}{ALL}, $gset, scalar(keys %{$geneset{$gset}}),
					$vclass, $n_obs1, sprintf("%.4f", $r_obs1), $n_obs2, sprintf("%.4f", $r_obs2), $ratio, $pval), "\n";
			}
		}
	}
}


open my $fsz, ">$output.sampsize.txt" or die "Cannot write to $output.sampsize.txt";
print $fsz join("\t", qw|SampleGroup N_Samps N_Males N_Females|), "\n";
foreach my $sgroup (@sampgroup) {
	print $fsz join("\t", $sgroup, map { $sampsize{$sgroup}{$_} } qw|ALL M F|), "\n";
}

# $varrm{$iid,$othervar}{$gene} = 1
if (%varrm) {
	open my $fvrm, ">$output.varrm.txt" or die "Cannot write to $output.varrm.txt";
	foreach my $viid (sort keys %varrm) {
		my ($iid, $varid) = split($;, $viid);
		foreach my $gid (sort keys %{$varrm{$viid}}) {
			print $fvrm join("\t", $iid, $varid, $gid), "\n";
		}
	}
}

# List gene-specific counts for gene-based test
# Enumerate all specified "sample group - variant class" combinations
if (exists $conf{GeneTab}) {
	my (@groupxclass, @header);
	foreach my $sgroup (split(',', $conf{GeneTab}{SampGroup})) {
		unless(grep { $sgroup eq $_ } @sampgroup) {
			die "Cannot find $sgroup in predefined sample groups";
		}
		foreach my $vclass (split(',', $conf{GeneTab}{VarClass})) {
			unless(grep { $vclass eq $_ } @varclass) {
				die "Cannot find $vclass in predefined variant class";
			}
			if (grep { $vclass eq $_ } @varclswogene) {
				die "Variant class $vclass is not associated with gene";
			}
			push @groupxclass, [$sgroup, $vclass];
			if (grep { $vclass eq $_ } @varclswrate) {
				push @header, "${sgroup}_${vclass}_Count", "${sgroup}_${vclass}_MutRate";
			}
			else {
				push @header, "${sgroup}_${vclass}_Count";
			}
		}
	}
	# Additional gene level information
	my ($xtraginfo, @gfields);
	if (defined $conf{GeneTab}{GXref}) {
		my ($xgdat, $xgfds) = slurp_xref($conf{GeneTab}{GXref}, $conf{GeneTab}{GXref_Fields});
		$xtraginfo = $xgdat;
		@gfields = @$xgfds;
		foreach my $gfield (@gfields) {
			if (grep { $gfield eq $_ } @header) {
				warn "Field $gfield already appear in the genetab output!";
			}
		}
	}
	open my $fgen, ">$output.genetab.txt" or die "Cannot write to $output.genetab.txt";
	print $fgen join("\t", "GeneID", @gfields, @header), "\n";
	foreach my $gid (sort keys %mutrate) {
		my @output;
		foreach my $sv (@groupxclass) {
			my ($sgroup, $vclass) = @$sv;
			push @output, $obsctbygene{$sgroup}{$gid}{$vclass} // 0;
			if (grep { $vclass eq $_ } @varclswrate) {
				push @output, sprintf("%.3E", $expratebygene{$sgroup}{$gid}{$vclass} * $scalefactor);
			}
		}
		my @ginfo;
		if (defined $xtraginfo) {
			@ginfo = map { $xtraginfo->{$gid}{$_} // "." } @gfields;  
		}
		print $fgen join("\t", $gid, @ginfo, @output), "\n";
	}
}

# List sample-specific counts for phenotype analysis
if (exists $conf{SampTab}) {
	my (@setxclass, @header);
	foreach my $gset (split(',', $conf{SampTab}{GeneSet})) {
		unless(grep { $gset eq $_ } (@geneset, ".")) {
			die "Cannot find $gset is predefined gene sets!";
		}
		foreach my $vclass (split(',', $conf{SampTab}{VarClass})) {
			unless(grep { $vclass eq $_ } @varclass) {
				die "Cannot find $vclass in predefined variant class";
			}
			push @setxclass, [$gset, $vclass];
			push @header, "${gset}_${vclass}_Count";
		}
	}
	# Additional sample level information
	my ($xtrasinfo, @sfields);
	if (defined $conf{SampTab}{SXref}) {
		my ($xsdat, $xsfds) = slurp_xref($conf{SampTab}{SXref}, $conf{SampTab}{SXref_Fields});
		$xtrasinfo = $xsdat;
		@sfields = @$xsfds;
		foreach my $sfield (@sfields) {
			if (grep { $sfield eq $_ } @header) {
				warn "Field $sfield already appear in the samptab output!"
			}
		}
	}
	open my $fsamp, ">$output.samptab.txt" or die "Cannot write to $output.samptab.txt";
	print $fsamp join("\t", "IID", @sfields, @header), "\n";
	foreach my $iid (sort keys %sampgroup) {
		my @output;
		foreach my $sv (@setxclass) {
			my ($gset, $vclass) = @$sv;
			push @output, $obsctbysamp{$iid}{$gset}{$vclass} // 0;
		}
		my @sinfo;
		if (defined $xtrasinfo) {
			@sinfo = map { $xtrasinfo->{$iid}{$_} // "." } @sfields;
		}
		print $fsamp join("\t", $iid, @sinfo, @output), "\n";
	}
}




