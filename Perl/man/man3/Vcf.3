.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Vcf 3"
.TH Vcf 3 "2018-01-30" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Vcf.pm.  Module for validation, parsing and creating VCF files. 
         Supported versions: 3.2, 3.3, 4.0, 4.1, 4.2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
From the command line:
    perl \-MVcf \-e validate example.vcf
    perl \-I/path/to/the/module/ \-MVcf \-e validate_v32 example.vcf
.PP
From a script:
    use Vcf;
.PP
.Vb 2
\&    my $vcf = Vcf\->new(file=>\*(Aqexample.vcf.gz\*(Aq,region=>\*(Aq1:1000\-2000\*(Aq);
\&    $vcf\->parse_header();
\&
\&    # Do some simple parsing. Most thorough but slowest way how to get the data.
\&    while (my $x=$vcf\->next_data_hash()) 
\&    { 
\&        for my $gt (keys %{$$x{gtypes}})
\&        {
\&            my ($al1,$sep,$al2) = $vcf\->parse_alleles($x,$gt);
\&            print "\et$gt: $al1$sep$al2\en";
\&        }
\&        print "\en";
\&    }
\&
\&    # This will split the fields and print a list of CHR:POS
\&    while (my $x=$vcf\->next_data_array()) 
\&    {
\&        print "$$x[0]:$$x[1]\en";
\&    }
\&
\&    # This will return the lines as they were read, including the newline at the end
\&    while (my $x=$vcf\->next_line()) 
\&    { 
\&        print $x;
\&    }
\&
\&    # Only the columns NA00001, NA00002 and NA00003 will be printed.
\&    my @columns = qw(NA00001 NA00002 NA00003);
\&    print $vcf\->format_header(\e@columns);
\&    while (my $x=$vcf\->next_data_array())
\&    {
\&        # this will recalculate AC and AN counts, unless $vcf\->recalc_ac_an was set to 0
\&        print $vcf\->format_line($x,\e@columns); 
\&    }
\&
\&    $vcf\->close();
.Ve
.SS "validate"
.IX Subsection "validate"
.Vb 6
\&    About   : Validates the VCF file.
\&    Usage   : perl \-MVcf \-e validate example.vcf.gz     # (from the command line)
\&              validate(\*(Aqexample.vcf.gz\*(Aq);               # (from a script)
\&              validate(\e*STDIN);
\&    Args    : File name or file handle. When no argument given, the first command line
\&              argument is interpreted as the file name.
.Ve
.SS "validate_v32"
.IX Subsection "validate_v32"
.Vb 4
\&    About   : Same as validate, but assumes v3.2 VCF version.
\&    Usage   : perl \-MVcf \-e validate_v32 example.vcf.gz     # (from the command line)
\&    Args    : File name or file handle. When no argument given, the first command line
\&              argument is interpreted as the file name.
.Ve
.SS "new"
.IX Subsection "new"
.Vb 9
\&    About   : Creates new VCF reader/writer. 
\&    Usage   : my $vcf = Vcf\->new(file=>\*(Aqmy.vcf\*(Aq, version=>\*(Aq3.2\*(Aq);
\&    Args    : 
\&                fh      .. Open file handle. If neither file nor fh is given, open in write mode.
\&                file    .. The file name. If neither file nor fh is given, open in write mode.
\&                region  .. Optional region to parse (requires tabix indexed VCF file)
\&                silent  .. Unless set to 0, warning messages may be printed.
\&                strict  .. Unless set to 0, the reader will die when the file violates the specification.
\&                version .. If not given, \*(Aq4.0\*(Aq is assumed. The header information overrides this setting.
.Ve
.SS "open"
.IX Subsection "open"
.Vb 5
\&    About   : (Re)Open file. No need to call this explicitly unless reading from a different 
\&              region is requested.
\&    Usage   : $vcf\->open(); # Read from the start
\&              $vcf\->open(region=>\*(Aq1:12345\-92345\*(Aq);
\&    Args    : region       .. Supported only for tabix indexed files
.Ve
.SS "close"
.IX Subsection "close"
.Vb 4
\&    About   : Close the filehandle
\&    Usage   : $vcf\->close();
\&    Args    : none
\&        Returns : close exit status
.Ve
.SS "next_line"
.IX Subsection "next_line"
.Vb 4
\&    About   : Reads next VCF line.
\&    Usage   : my $vcf = Vcf\->new(); 
\&              my $x   = $vcf\->next_line();
\&    Args    : none
.Ve
.SS "next_data_array"
.IX Subsection "next_data_array"
.Vb 5
\&    About   : Reads next VCF line and splits it into an array. The last element is chomped.
\&    Usage   : my $vcf = Vcf\->new(); 
\&              $vcf\->parse_header(); 
\&              my $x = $vcf\->next_data_array();
\&    Args    : Optional line to parse
.Ve
.SS "set_samples"
.IX Subsection "set_samples"
.Vb 6
\&    About   : Parsing big VCF files with many sample columns is slow, not parsing unwanted samples may speed things a bit.
\&    Usage   : my $vcf = Vcf\->new(); 
\&              $vcf\->set_samples(include=>[\*(AqNA0001\*(Aq]);   # Exclude all but this sample. When the array is empty, all samples will be excluded.
\&              $vcf\->set_samples(exclude=>[\*(AqNA0003\*(Aq]);   # Include only this sample. When the array is empty, all samples will be included.
\&              my $x = $vcf\->next_data_hash();
\&    Args    : Optional line to parse
.Ve
.SS "next_data_hash"
.IX Subsection "next_data_hash"
.Vb 4
\&    About   : Reads next VCF line and splits it into a hash. This is the slowest way to obtain the data.
\&    Usage   : my $vcf = Vcf\->new(); 
\&              $vcf\->parse_header(); 
\&              my $x = $vcf\->next_data_hash();
\&
\&              # Or having a VCF data line $line
\&              my $x = $vcf\->next_data_hash($line);
\&
\&    Args    : Optional line to parse.
.Ve
.SS "parse_header"
.IX Subsection "parse_header"
.Vb 3
\&    About   : Reads (and stores) the VCF header.
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header();
\&    Args    : silent .. do not warn about duplicate header lines
.Ve
.SS "_next_header_line"
.IX Subsection "_next_header_line"
.Vb 2
\&    About   : Stores the header lines and meta information, such as fields types, etc.
\&    Args    : silent .. do not warn about duplicate column names
.Ve
.SS "get_header_line"
.IX Subsection "get_header_line"
.Vb 6
\&    Usage   : $vcf\->get_header_line(key=>\*(AqINFO\*(Aq, ID=>\*(AqAC\*(Aq)
\&              $vcf\->get_header_line(key=>\*(AqFILTER\*(Aq, ID=>\*(Aqq10\*(Aq)
\&              $vcf\->get_header_line(key=>\*(Aqreference\*(Aq)
\&              $vcf\->get_header_line(key=>\*(Aqcontig\*(Aq,ID=>\*(Aq20\*(Aq)
\&    Args    : Header line filter as in the example above
\&    Returns : List ref of header line hashes matching the filter
.Ve
.SS "add_header_line"
.IX Subsection "add_header_line"
.Vb 7
\&    Usage   : $vcf\->add_header_line({key=>\*(AqINFO\*(Aq, ID=>\*(AqAC\*(Aq,Number=>\-1,Type=>\*(AqInteger\*(Aq,Description=>\*(AqAllele count in genotypes\*(Aq})
\&              $vcf\->add_header_line({key=>\*(Aqreference\*(Aq,value=>\*(Aq1000GenomesPilot\-NCBI36\*(Aq})
\&    Args    : Header line hash as in the example above
\&              Hash with additional parameters [optional]
\&                silent .. do not warn about existing header keys
\&                append .. append timestamp to the name of the new one
\&    Returns :
.Ve
.SS "remove_header_line"
.IX Subsection "remove_header_line"
.Vb 3
\&    Usage   : $vcf\->remove_header_line(key=>\*(AqINFO\*(Aq, ID=>\*(AqAC\*(Aq)
\&    Args    :
\&    Returns :
.Ve
.SS "parse_header_line"
.IX Subsection "parse_header_line"
.Vb 4
\&    Usage   : $vcf\->parse_header_line(q[##reference=1000GenomesPilot\-NCBI36])
\&              $vcf\->parse_header_line(q[##INFO=NS,1,Integer,"Number of Samples With Data"])
\&    Args    : 
\&    Returns :
.Ve
.SS "_read_column_names"
.IX Subsection "_read_column_names"
.Vb 4
\&    About   : Stores the column names as array $$self{columns} and hash $$self{has_column}{COL_NAME}=index.
\&              The indexes go from 1.
\&    Usage   : $vcf\->_read_column_names();
\&    Args    : none
.Ve
.SS "_fake_column_names"
.IX Subsection "_fake_column_names"
.Vb 2
\&    About   : When no header is present, fake column names as the default mandatory ones + numbers
\&    Args    : The number of genotype columns; 0 if no genotypes but FORMAT present; <0 if FORMAT and genotypes not present
.Ve
.SS "format_header"
.IX Subsection "format_header"
.Vb 3
\&    About   : Returns the header.
\&    Usage   : print $vcf\->format_header();
\&    Args    : The columns to include on output [optional]
.Ve
.SS "format_line"
.IX Subsection "format_line"
.Vb 5
\&    About   : Returns the header.
\&    Usage   : $x = $vcf\->next_data_hash(); print $vcf\->format_line($x);
\&              $x = $vcf\->next_data_array(); print $vcf\->format_line($x);
\&    Args 1  : The columns or hash in the format returned by next_data_hash or next_data_array.
\&         2  : The columns to include [optional]
.Ve
.SS "recalc_ac_an"
.IX Subsection "recalc_ac_an"
.Vb 5
\&    About   : Control if the AC and AN values should be updated.
\&    Usage   : $vcf\->recalc_ac_an(1); $x = $vcf\->next_data_hash(); print $vcf\->format_line($x);
\&    Args 1  : 0 .. never recalculate
\&              1 .. recalculate if present
\&              2 .. recalculate if present and add if missing
.Ve
.SS "get_tag_index"
.IX Subsection "get_tag_index"
.Vb 5
\&    Usage   : my $idx = $vcf\->get_tag_index(\*(AqGT:PL:DP:SP:GQ\*(Aq,\*(AqPL\*(Aq,\*(Aq:\*(Aq);
\&    Arg 1   : Field
\&        2   : The tag to find
\&        3   : Tag separator
\&    Returns : Index of the tag or \-1 when not found
.Ve
.SS "remove_field"
.IX Subsection "remove_field"
.Vb 5
\&    Usage   : my $field = $vcf\->remove_field(\*(AqGT:PL:DP:SP:GQ\*(Aq,1,\*(Aq:\*(Aq);    # returns \*(AqGT:DP:SP:GQ\*(Aq
\&    Arg 1   : Field
\&        2   : The index of the field to remove
\&        3   : Field separator
\&    Returns : Modified string
.Ve
.SS "replace_field"
.IX Subsection "replace_field"
.Vb 6
\&    Usage   : my $col = $vcf\->replace_field(\*(AqGT:PL:DP:SP:GQ\*(Aq,\*(AqXX\*(Aq,1,\*(Aq:\*(Aq);    # returns \*(AqGT:XX:DP:SP:GQ\*(Aq
\&    Arg 1   : Field
\&        2   : Replacement
\&        3   : 0\-based index of the field to replace
\&        4   : Field separator
\&    Returns : Modified string
.Ve
.SS "get_info_field"
.IX Subsection "get_info_field"
.Vb 8
\&    Usage   : my $line  = $vcf\->next_line;
\&              my @items = split(/\et/,$line); 
\&              $af = $vcf\->get_info_field(\*(AqDP=14;AF=0.5;DB\*(Aq,\*(AqAF\*(Aq);    # returns 0.5
\&              $af = $vcf\->get_info_field(\*(AqDP=14;AF=0.5;DB\*(Aq,\*(AqDB\*(Aq);    # returns 1
\&              $af = $vcf\->get_info_field(\*(AqDP=14;AF=0.5;DB\*(Aq,\*(AqXY\*(Aq);    # returns undef
\&    Arg 1   : The VCF line broken into an array
\&        2   : The tag to retrieve
\&    Returns : undef when tag is not present, the tag value if present, or 1 if flag is present
.Ve
.SS "get_field"
.IX Subsection "get_field"
.Vb 8
\&    Usage   : my $line  = $vcf\->next_line;
\&              my @items = split(/\et/,$line); 
\&              my $idx = $vcf\->get_tag_index($$line[8],\*(AqPL\*(Aq,\*(Aq:\*(Aq); 
\&              my $pl  = $vcf\->get_field($$line[9],$idx) unless $idx==\-1;
\&    Arg 1   : The VCF line broken into an array
\&        2   : The index of the field to retrieve
\&        3   : The delimiter [Default is \*(Aq:\*(Aq]
\&    Returns : The tag value
.Ve
.SS "get_sample_field"
.IX Subsection "get_sample_field"
.Vb 7
\&    Usage   : my $line  = $vcf\->next_line;
\&              my @items = split(/\et/,$line); 
\&              my $idx = $vcf\->get_tag_index($$line[8],\*(AqPL\*(Aq,\*(Aq:\*(Aq); 
\&              my $pls = $vcf\->get_sample_field(\e@items,$idx) unless $idx==\-1;
\&    Arg 1   : The VCF line broken into an array
\&        2   : The index of the field to retrieve
\&    Returns : Array of values
.Ve
.SS "split_mandatory"
.IX Subsection "split_mandatory"
.Vb 4
\&    About   : Faster alternative to regexs, extract the mandatory columns
\&    Usage   : my $line=$vcf\->next_line; my @cols = $vcf\->split_mandatory($line);
\&    Arg     : 
\&    Returns : Pointer to the array of values
.Ve
.SS "split_gt"
.IX Subsection "split_gt"
.Vb 4
\&    About   : Faster alternative to regexs
\&    Usage   : my ($a1,$a2,$a3) = $vcf\->split_gt(\*(Aq0/0/1\*(Aq); # returns (0,0,1)
\&    Arg     : Diploid genotype to split into alleles
\&    Returns : Array of values
.Ve
.SS "split_by"
.IX Subsection "split_by"
.Vb 4
\&    About   : Generalization of split_gt
\&    Usage   : my ($a1,$a2,$a3) = $vcf\->split_gt(\*(Aq0/0|1\*(Aq,qw(| /)); # returns (0,0,1)
\&    Arg     : Diploid genotype to split into alleles
\&    Returns : Array of values
.Ve
.SS "decode_genotype"
.IX Subsection "decode_genotype"
.Vb 6
\&    About   : Faster alternative to regexs
\&    Usage   : my $gt = $vcf\->decode_genotype(\*(AqG\*(Aq,[\*(AqA\*(Aq,\*(AqC\*(Aq],\*(Aq0/0\*(Aq); # returns \*(AqG/G\*(Aq
\&    Arg   1 : Ref allele
\&          2 : Alt alleles
\&          3 : The genotype to decode
\&    Returns : Decoded GT string
.Ve
.SS "validate_alt_field"
.IX Subsection "validate_alt_field"
.Vb 3
\&    Usage   : my $x = $vcf\->next_data_hash(); $vcf\->validate_alt_field($$x{ALT});
\&    Args    : The ALT arrayref
\&    Returns : Error message in case of an error.
.Ve
.SS "event_type"
.IX Subsection "event_type"
.Vb 10
\&    Usage   :   my $x = $vcf\->next_data_hash(); 
\&                my ($alleles,$seps,$is_phased,$is_empty) = $vcf\->parse_haplotype($x,\*(AqNA00001\*(Aq);
\&                for my $allele (@$alleles)
\&                {
\&                    my ($type,$len,$ht) = $vcf\->event_type($x,$allele);
\&                }
\&              or
\&                my ($type,$len,$ht) = $vcf\->event_type($ref,$al);
\&    Args    : VCF data line parsed by next_data_hash or the reference allele
\&            : Allele
\&    Returns :   \*(Aqs\*(Aq for SNP and number of SNPs in the record
\&                \*(Aqi\*(Aq for indel and a positive (resp. negative) number for the length of insertion (resp. deletion)
\&                \*(Aqr\*(Aq identical to the reference, length 0
\&                \*(Aqo\*(Aq for other (complex events) and the number of affected bases
\&                \*(Aqb\*(Aq breakend
\&                \*(Aqu\*(Aq unknown
.Ve
.SS "has_AGtags"
.IX Subsection "has_AGtags"
.Vb 4
\&    About   : Checks the header for the presence of tags with variable number of fields (Number=A or Number=G, such as GL)
\&    Usage   : $vcf\->parse_header(); my $agtags = $vcf\->has_AGtags();
\&    Args    : None
\&    Returns : Hash {fmtA=>[tags],fmtG=>[tags],infoA=>[tags],infoG=>[tags]} or undef if none is present
.Ve
.SS "parse_AGtags"
.IX Subsection "parse_AGtags"
.Vb 6
\&    About   : Breaks tags with variable number of fields (that is where Number is set to \*(AqA\*(Aq or \*(AqG\*(Aq, such as GL) into hashes
\&    Usage   : my $x = $vcf\->next_data_hash(); my $values = $vcf\->parse_AGtags($x);
\&    Args    : VCF data line parsed by next_data_hash
\&            : Mapping between ALT representations based on different REFs [optional]
\&            : New REF [optional]
\&    Returns : Hash {Allele=>Value}
.Ve
.SS "format_AGtag"
.IX Subsection "format_AGtag"
.Vb 6
\&    About   : Format tag with variable number of fields (that is where Number is set to \*(AqA\*(Aq or \*(AqG\*(Aq, such as GL)
\&    Usage   : 
\&    Args    : 
\&            : 
\&            : 
\&    Returns :
.Ve
.SS "parse_alleles"
.IX Subsection "parse_alleles"
.Vb 5
\&    About   : Deprecated, use parse_haplotype instead.
\&    Usage   : my $x = $vcf\->next_data_hash(); my ($al1,$sep,$al2) = $vcf\->parse_alleles($x,\*(AqNA00001\*(Aq);
\&    Args    : VCF data line parsed by next_data_hash
\&            : The genotype column name
\&    Returns : Alleles and the separator. If only one allele is present, $sep and $al2 will be an empty string.
.Ve
.SS "parse_haplotype"
.IX Subsection "parse_haplotype"
.Vb 6
\&    About   : Similar to parse_alleles, supports also multiploid VCFs. 
\&    Usage   : my $x = $vcf\->next_data_hash(); my ($alleles,$seps,$is_phased,$is_empty) = $vcf\->parse_haplotype($x,\*(AqNA00001\*(Aq);
\&    Args    : VCF data line parsed by next_data_hash
\&            : The genotype column name
\&    Returns : Two array refs and two boolean flags: List of alleles, list of separators, and is_phased/empty flags. The values
\&                can be cashed and must be therefore considered read only!
.Ve
.SS "format_haplotype"
.IX Subsection "format_haplotype"
.Vb 1
\&    Usage   : my ($alleles,$seps,$is_phased,$is_empty) = $vcf\->parse_haplotype($x,\*(AqNA00001\*(Aq); print $vcf\->format_haplotype($alleles,$seps);
.Ve
.SS "format_genotype_strings"
.IX Subsection "format_genotype_strings"
.Vb 8
\&    Usage   : my $x = { REF=>\*(AqA\*(Aq, gtypes=>{\*(AqNA00001\*(Aq=>{\*(AqGT\*(Aq=>\*(AqA/C\*(Aq}}, FORMAT=>[\*(AqGT\*(Aq], CHROM=>1, POS=>1, FILTER=>[\*(Aq.\*(Aq], QUAL=>\-1 };
\&              $vcf\->format_genotype_strings($x); 
\&              print $vcf\->format_line($x);
\&    Args 1  : VCF data line in the format as if parsed by next_data_hash with alleles written as letters.
\&         2  : Optionally, a subset of columns can be supplied. See also format_line.
\&    Returns : Modifies the ALT array and the genotypes so that ref alleles become 0 and non\-ref alleles 
\&                numbers starting from 1. If the key $$vcf{trim_redundant_ALTs} is set, ALT alleles not appearing
\&                in any of the sample column will be removed.
.Ve
.SS "format_header_line"
.IX Subsection "format_header_line"
.Vb 3
\&    Usage   : $vcf\->format_header_line({key=>\*(AqINFO\*(Aq, ID=>\*(AqAC\*(Aq,Number=>\-1,Type=>\*(AqInteger\*(Aq,Description=>\*(AqAllele count in genotypes\*(Aq})
\&    Args    : 
\&    Returns :
.Ve
.SS "remove_columns"
.IX Subsection "remove_columns"
.Vb 4
\&    Usage   : my $rec=$vcf\->next_data_hash(); $vcf\->remove_columns($rec,remove=>[\*(AqNA001\*(Aq,\*(AqNA0002\*(Aq]);
\&    Args    : VCF hash pointer
\&            : list of columns to remove or a lookup hash with column names to keep (remove=>[] or keep=>{})
\&    Returns :
.Ve
.SS "add_columns"
.IX Subsection "add_columns"
.Vb 3
\&    Usage   : $vcf\->add_columns(\*(AqNA001\*(Aq,\*(AqNA0002\*(Aq);
\&    Args    : 
\&    Returns :
.Ve
.SS "add_format_field"
.IX Subsection "add_format_field"
.Vb 4
\&    Usage   : $x=$vcf\->next_data_hash(); $vcf\->add_format_field($x,\*(AqFOO\*(Aq); $$x{gtypes}{NA0001}{FOO}=\*(AqBar\*(Aq; print $vcf\->format_line($x);
\&    Args    : The record obtained by next_data_hash
\&            : The field name
\&    Returns :
.Ve
.SS "remove_format_field"
.IX Subsection "remove_format_field"
.Vb 4
\&    Usage   : $x=$vcf\->next_data_hash(); $vcf\->remove_format_field($x,\*(AqFOO\*(Aq); print $vcf\->format_line($x);
\&    Args    : The record obtained by next_data_hash
\&            : The field name
\&    Returns :
.Ve
.SS "add_info_field"
.IX Subsection "add_info_field"
.Vb 5
\&    Usage   : $x=$vcf\->next_data_array(); $$x[7]=$vcf\->add_info_field($$x[7],\*(AqFOO\*(Aq=>\*(Aqvalue\*(Aq,\*(AqBAR\*(Aq=>undef,\*(AqBAZ\*(Aq=>\*(Aq\*(Aq); print join("\et",@$x)."\en";
\&    Args    : The record obtained by next_data_array
\&            : The INFO field name and value pairs. If value is undef and the key is present in $$x[7],
\&                it will be removed. To add fields without a value, use empty string \*(Aq\*(Aq.
\&    Returns : The formatted INFO.
.Ve
.SS "add_filter"
.IX Subsection "add_filter"
.Vb 4
\&    Usage   : $x=$vcf\->next_data_array(); $$x[6]=$vcf\->add_filter($$x[6],\*(AqSnpCluster\*(Aq=>1,\*(Aqq10\*(Aq=>0); print join("\et",@$x)."\en";
\&    Args    : The record obtained by next_data_array or next_data_hash
\&            : The key\-value pairs for filter to be added. If value is 1, the filter will be added. If 0, the filter will be removed.
\&    Returns : The formatted filter field.
.Ve
.SS "validate_filter_field"
.IX Subsection "validate_filter_field"
.Vb 3
\&    Usage   : my $x = $vcf\->next_data_hash(); $vcf\->validate_filter_field($$x{FILTER});
\&    Args    : The FILTER arrayref
\&    Returns : Error message in case of an error.
.Ve
.SS "validate_header"
.IX Subsection "validate_header"
.Vb 3
\&    About   : Version specific header validation code.
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header(); $vcf\->validate_header();
\&    Args    :
.Ve
.SS "validate_line"
.IX Subsection "validate_line"
.Vb 3
\&    About   : Version specific line validation code.
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header(); $x = $vcf\->next_data_hash; $vcf\->validate_line($x);
\&    Args    :
.Ve
.SS "validate_info_field"
.IX Subsection "validate_info_field"
.Vb 3
\&    Usage   : my $x = $vcf\->next_data_hash(); $vcf\->validate_info_field($$x{INFO},$$x{ALT});
\&    Args    : The INFO hashref
\&    Returns : Error message in case of an error.
.Ve
.SS "validate_gtype_field"
.IX Subsection "validate_gtype_field"
.Vb 4
\&    Usage   : my $x = $vcf\->next_data_hash(); $vcf\->validate_gtype_field($$x{gtypes}{NA00001},$$x{ALT},$$x{FORMAT});
\&    Args    : The genotype data hashref
\&              The ALT arrayref
\&    Returns : Error message in case of an error.
.Ve
.SS "run_validation"
.IX Subsection "run_validation"
.Vb 3
\&    About   : Validates the VCF file.
\&    Usage   : my $vcf = Vcf\->new(file=>\*(Aqfile.vcf\*(Aq); $vcf\->run_validation(\*(Aqexample.vcf.gz\*(Aq);
\&    Args    : File name or file handle.
.Ve
.SS "get_chromosomes"
.IX Subsection "get_chromosomes"
.Vb 3
\&    About   : Get list of chromosomes from the VCF file. Must be bgzipped and tabix indexed.
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->get_chromosomes();
\&    Args    : none
.Ve
.SS "get_samples"
.IX Subsection "get_samples"
.Vb 3
\&    About   : Get list of samples.
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header(); my (@samples) = $vcf\->get_samples();
\&    Args    : none
.Ve
.SS "get_column"
.IX Subsection "get_column"
.Vb 4
\&    About   : Convenient way to get data for a sample
\&    Usage   : my $rec = $vcf\->next_data_array(); my $sample_col = $vcf\->get_column($rec, \*(AqNA0001\*(Aq);
\&    Args 1  : Array pointer returned by next_data_array
\&         2  : Column/Sample name
.Ve
.SS "get_column_name"
.IX Subsection "get_column_name"
.Vb 3
\&    About   : Mapping between zero\-based VCF column and its name
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header(); my $name = $vcf\->get_column_name(1); # returns POS
\&    Args    : Index of the column (0\-based)
.Ve
.SS "get_column_index"
.IX Subsection "get_column_index"
.Vb 3
\&    About   : Mapping between VCF column name and its zero\-based index
\&    Usage   : my $vcf = Vcf\->new(); $vcf\->parse_header(); my $name = $vcf\->get_column_index(\*(AqPOS\*(Aq); # returns 1
\&    Args    : Name of the column
.Ve
.SH "VCFv4.0"
.IX Header "VCFv4.0"
VCFv4.0 specific functions
.SS "parse_header_line"
.IX Subsection "parse_header_line"
.Vb 4
\&    Usage   : $vcf\->parse_header_line(q[##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">])
\&              $vcf\->parse_header_line(q[reference=1000GenomesPilot\-NCBI36])
\&    Args    : 
\&    Returns :
.Ve
.SS "fill_ref_alt_mapping"
.IX Subsection "fill_ref_alt_mapping"
.Vb 12
\&    About   : A tool for merging VCFv4.0 records. The subroutine unifies the REFs and creates a mapping
\&                from the original haplotypes to the haplotypes based on the new REF. Consider the following
\&                example:
\&                    REF ALT
\&                    G    GA
\&                    GT   G
\&                    GT   GA
\&                    GT   GAA
\&                    GTC  G
\&                    G    <DEL>
\&                my $map={G=>{GA=>1},GT=>{G=>1,GA=>1,GAA=>1},GTC=>{G=>1},G=>{\*(Aq<DEL>\*(Aq=>1}};
\&                my $new_ref=$vcf\->fill_ref_alt_mapping($map);
\&                
\&              The call returns GTC and $map is now
\&                    G    GA     \->      GTC  GATC
\&                    GT   G      \->      GTC  GC
\&                    GT   GA     \->      GTC  GAC
\&                    GT   GAA    \->      GTC  GAAC
\&                    GTC  G      \->      GTC  G
\&                    G    <DEL>  \->      GTC  <DEL>
\&    Args    : 
\&    Returns : New REF string and fills the hash with appropriate ALT or undef on error.
.Ve
.SS "normalize_alleles"
.IX Subsection "normalize_alleles"
.Vb 3
\&    About   : Makes REF and ALT alleles more compact if possible (e.g. TA,TAA \-> T,TA)
\&    Usage   : my $line = $vcf\->next_data_array();
\&              ($ref,@alts) = $vcf\->normalize_alleles($$line[3],$$line[4]);
.Ve
.SH "VCFv4.1"
.IX Header "VCFv4.1"
VCFv4.1 specific functions
.SH "VCFv4.2"
.IX Header "VCFv4.2"
VCFv4.2 specific functions
.SH "VCFv4.3"
.IX Header "VCFv4.3"
VCFv4.2 specific functions
