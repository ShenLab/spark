.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Genet::Ped 3"
.TH Genet::Ped 3 "2019-03-20" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Genet::Ped \- Simple Pedigree Tools.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module represent family structures in directed graphs to facilitate querying
simple relationships.
.PP
The information from a six-column ped file is necessary to construct pedigree
structures. Sample level information like gender and affection status are stored
as attributes of graph level. We only support minimal level information obtained
from ped file.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Genet::Ped
\&
\&    my $ped = Genet::Ped\->new($pedfile);
\&
\&    my @pos = $ped\->get\->po_pairs;
\&    my @sibs = $ped\->get\->sib_pairs;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
A list of functions that can be exported.  You can delete this section
if you don't export anything, such as for a purely object-oriented module.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "Class\->new \s-1PEDFILE\s0 [, \s-1OPTIONS\s0]"
.IX Subsection "Class->new PEDFILE [, OPTIONS]"
New from a ped file. First 5 or 6 columns will be used.
\&\s-1PED\s0 file can be text file in plink \s-1FAM\s0 or merlin \s-1PED\s0 format, or an array ref to hash refs
represent each individual in \s-1PED\s0 file, or simply the resulting arrayref with \s-1FID\s0 as key.
.PP
Options:
.PP
* \f(CW\*(C`strict\*(C'\fR : under strict mode, all samples should have non-missing sex, all parents
must also appear in the pedigree, and pedigree graph can have and only has one connected
component.
.PP
* \f(CW\*(C`ignore\*(C'\fR : patterns of sample names to ignore, this is typical when technical duplicates
are included. Those samples should not appear in parents.
.PP
* \f(CW\*(C`nopheno\*(C'\fR : no phenotype column.
.PP
* \f(CW\*(C`splitfam\*(C'\fR : under non-strict mode, when multiple connected component exist, split them
into different families ordered by family size. Suffices .1,.2 will be added to the orignal 
\&\s-1FID\s0 to create new \s-1FID\s0 for splitted families.
.PP
* \f(CW\*(C`sep\*(C'\fR : separator between \s-1FID\s0 and suffix when \f(CW\*(C`splitfam\*(C'\fR is enabled, default is '.'.
.PP
* \f(CW\*(C`verbose\*(C'\fR : output debug information.
.ie n .SS "$self\->sub_ped \s-1FAMID, COMPONENTS\s0"
.el .SS "\f(CW$self\fP\->sub_ped \s-1FAMID, COMPONENTS\s0"
.IX Subsection "$self->sub_ped FAMID, COMPONENTS"
Split large family into multiple sub-families.
.PP
\&\s-1COMPNENTS\s0 is an array of IIDs used for reconstruct multiple sub-families. One individual can exist in more 
than one sub-families. \s-1COMPNENTS\s0 will be sorted based on the sample size. After splitting, sufficies 1,2,... 
will be appended to family IDs. Suffix separator is '.' by default, if it is conflict with other family IDs,
then it can be specified as by the <\f(CW\*(C`sep\*(C'\fR option.
.PP
It returns a \f(CW\*(C`Genet::Ped\*(C'\fR object, with all other methods avaiable.
.ie n .SS "$self\->clone \s-1FAMID\s0(s)"
.el .SS "\f(CW$self\fP\->clone \s-1FAMID\s0(s)"
.IX Subsection "$self->clone FAMID(s)"
Clone data structure for a subset of families.
.ie n .SS "$self\->write \s-1FILE\s0 [, \s-1OPTIONS\s0]"
.el .SS "\f(CW$self\fP\->write \s-1FILE\s0 [, \s-1OPTIONS\s0]"
.IX Subsection "$self->write FILE [, OPTIONS]"
Write pedigrees into a file. \s-1FILE\s0 can be file name or handle.
.PP
Parents that are not exist in original \s-1PED\s0 file will be excluded.
.PP
Depending on the new option, unconnected components can be in the same or difrerent families.
.PP
Options:
.PP
* \f(CW\*(C`famids\*(C'\fR : output a subset of families (array ref).
.PP
* \f(CW\*(C`miss\*(C'\fR : by default mssing gender and phenotypes will coded as 0.
.PP
* \f(CW\*(C`nophe\*(C'\fR : do not output phenotype column.
.SS "Accessors for Family"
.IX Subsection "Accessors for Family"
For methods accepting \s-1FAMID,\s0 when \s-1FAMID\s0 is not provided,  will return a hash of (\s-1FID\s0 => value) pairs.
.PP
\fIget_famids\fR
.IX Subsection "get_famids"
.PP
Return a list of family IDs.
.PP
\fIget_sampsize\fR
.IX Subsection "get_sampsize"
.PP
Get total number of samples
.PP
\fIget_members [\s-1FAMID\s0]\fR
.IX Subsection "get_members [FAMID]"
.PP
Get all family members.
.PP
\fIget_famsize [\s-1FAMID\s0]\fR
.IX Subsection "get_famsize [FAMID]"
.PP
Get family sizes.
.PP
\fIget_founder [\s-1FAMID\s0]\fR
.IX Subsection "get_founder [FAMID]"
.PP
Get all founders in the family.
.PP
\fIget_nonfounders [\s-1FAMID\s0]\fR
.IX Subsection "get_nonfounders [FAMID]"
.PP
Get all offspring in the family.
.PP
\fIget_numgen\fR
.IX Subsection "get_numgen"
.PP
Get the number of generations.
.PP
\fIget_connected [\s-1FAMID\s0]\fR
.IX Subsection "get_connected [FAMID]"
.PP
Get weakly connected components (cc).
.PP
Under strict mode, one family can have at most one cc. The presence of more than on cc
indicate some extended relationship in the family, but due to absence of parents, they are
not connected.
.PP
\fIis_bipar [\s-1FAMID\s0]\fR
.IX Subsection "is_bipar [FAMID]"
.PP
Test if all offspring have two parents.
.SS "Accessors for Individual"
.IX Subsection "Accessors for Individual"
All methods accept \s-1FAMID\s0 and \s-1IID. IID\s0 is optional, when omitted, it will return a hash of 
(\s-1IID\s0 => value) pairs.
.PP
\fIget_sex/aff \s-1FAMID, IID\s0\fR
.IX Subsection "get_sex/aff FAMID, IID"
.PP
Get gender/affection status for FAMID-IID
.PP
The previous hard coded version for get sex/affection status for FAMID-IID
.PP
sub get_sex {
	my ($self, \f(CW$famid\fR, \f(CW$iid\fR) = \f(CW@_\fR;
	croak \*(L"Cannot find Family \f(CW$famid\fR\*(R" unless defined \f(CW$self\fR\->{$famid};
	my \f(CW$ped\fR = \f(CW$self\fR\->{$famid};
	if (defined \f(CW$iid\fR) {
		croak \*(L"Cannot find \f(CW$iid\fR in Family \f(CW$famid\fR\*(R" unless \f(CW$ped\fR\->has_vertex($iid);
		my \f(CW$sex\fR = \f(CW$ped\fR\->get_vertex_attribute($iid, \*(L"\s-1SEX\*(R"\s0);
		return \f(CW$sex\fR;
	}
	else {
		my \f(CW%sex\fR;
		foreach my \f(CW$iid\fR ($self\->get_members($famid)) {
			\f(CW$sex\fR{$iid} = \f(CW$ped\fR\->get_vertex_attribute($iid, \*(L"\s-1SEX\*(R"\s0);
		}
		if (wantarray) {
			return \f(CW%sex\fR;
		}
		else {
			return \e%sex;
		}
	}
}
.PP
sub get_aff {
	my ($self, \f(CW$famid\fR, \f(CW$iid\fR) = \f(CW@_\fR;
	croak \*(L"Cannot find Family \f(CW$famid\fR\*(R" unless defined \f(CW$self\fR\->{$famid};
	my \f(CW$ped\fR = \f(CW$self\fR\->{$famid};
	if (defined \f(CW$iid\fR) {
		croak \*(L"Cannot find \f(CW$iid\fR in Family \f(CW$famid\fR\*(R" unless \f(CW$ped\fR\->has_vertex($iid);
		my \f(CW$aff\fR = \f(CW$ped\fR\->get_vertex_attribute($iid, \*(L"\s-1AFF\*(R"\s0);
		return \f(CW$aff\fR;
	}
	else {
		my \f(CW%aff\fR;
		foreach my \f(CW$iid\fR ($self\->get_members($famid)) {
			\f(CW$aff\fR{$iid} = \f(CW$ped\fR\->get_vertex_attribute($iid, \*(L"\s-1AFF\*(R"\s0);
		}
		if (wantarray) {
			return \f(CW%aff\fR;
		}
		else {
			return \e%aff;
		}
	}
}
.PP
\fIget_parents \s-1FAMID, IID\s0\fR
.IX Subsection "get_parents FAMID, IID"
.PP
Get parents for FAMID-IID.
.PP
The order of parents is sorted by sex, so when both parents are present father come first.
.PP
\fIget_offspring \s-1FAMID, IID\s0\fR
.IX Subsection "get_offspring FAMID, IID"
.PP
Get offsprings for FAMID-IID
.PP
sub _offspring {
	my ($ped, \f(CW$iid\fR) = \f(CW@_\fR;
	my \f(CW@children\fR = \f(CW$ped\fR\->successors($iid);
	return \f(CW@children\fR;
}
.PP
sub get_offspring {
	my ($self, \f(CW$famid\fR, \f(CW$iid\fR) = \f(CW@_\fR;
	croak \*(L"Must provide family \s-1ID\*(R"\s0 unless defined \f(CW$famid\fR;
	croak \*(L"Cannot find Family \f(CW$famid\fR\*(R" unless defined \f(CW$self\fR\->{$famid};
	if (defined \f(CW$iid\fR) {
		croak \*(L"Cannot find \f(CW$iid\fR in Family \f(CW$famid\fR\*(R" unless \f(CW$self\fR\->{$famid}\->has_vertex($iid);
		return _offspring($self\->{$famid}, \f(CW$iid\fR);
	}
	else {
		my \f(CW%offspring\fR;
		foreach my \f(CW$iid\fR ($self\->get_members($famid)) {
			my \f(CW@children\fR = _offspring($self\->{$famid}, \f(CW$iid\fR);
			if (@children > 0) {
				\f(CW$offspring\fR{$iid} = [@children];
			}
		}
		if (wantarray) {
			return \f(CW%offspring\fR;
		}
		else {
			return \e%offspring;
		}
	}
}
.PP
\fIget_father/mother \s-1FAMID, IID\s0\fR
.IX Subsection "get_father/mother FAMID, IID"
.PP
Get father or mother for FAM-IID.
.PP
\fIis_founder \s-1FAMID, IID\s0\fR
.IX Subsection "is_founder FAMID, IID"
.PP
Test if a individual is a founder.
.SS "Computed Accessors for Family"
.IX Subsection "Computed Accessors for Family"
\fIget_po_pairs \s-1FAMID\s0\fR
.IX Subsection "get_po_pairs FAMID"
.PP
Get all parent-offspring pairs within families.
.PP
\fIget_sib_pairs / get_all_sibpairs \s-1FAMID\s0\fR
.IX Subsection "get_sib_pairs / get_all_sibpairs FAMID"
.PP
get_sib_pairs : Get full sib pairs within families, who must share both parents 
  and parents should present in the ped file.
.PP
get_all_sibpairs: Get all sib pairs, including those who only share one parent.
.SS "get_trios \s-1FAMID\s0"
.IX Subsection "get_trios FAMID"
Get offspring-father-mother trios.
.SH "AUTHOR"
.IX Header "AUTHOR"
Xueya Zhou, \f(CW\*(C`<xueyazhou at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-genet at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Genet>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Genet::Ped
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Genet>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Genet>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Genet>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Genet/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2018 Xueya Zhou.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the the Artistic License (1.0). You may obtain a
copy of the full license at:
.PP
<http://www.perlfoundation.org/artistic_license_1_0>
.PP
Aggregation of this Package with a commercial distribution is always
permitted provided that the use of this Package is embedded; that is,
when no overt attempt is made to make this Package's interfaces visible
to the end user of the commercial distribution. Such use shall not be
construed as a distribution of this Package.
.PP
The name of the Copyright Holder may not be used to endorse or promote
products derived from this software without specific prior written
permission.
.PP
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
