.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Utils::Workflow 3"
.TH Utils::Workflow 3 "2020-12-29" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Utils::Workflow \- Workflow management.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&        my $wkf = Utils::Workflow\->new($rootdir, {engine => \*(AqBASH\*(Aq});
\&        $wkf\->add(\e*GATK_DOC, { name => "GATK_DoC" slots => 200, expect => { out => docfile } });
\&        $wkf\->add(\e*PREP_INTV, { name => "Prep_Intv", expect => { wrk => interval }});
\&        $wkf\->add(\e*PICARD_DOC, { name => "Picard_DoC", slots => 200, depend => "PREP_INTV",
\&                expect => { out => docfile2 } });
\&
\&        use Config::Simple;
\&        my (%path, %resource);
\&        Config::Simple\->import_from($pathfile, \e%path)
\&        Config::Simple\->import_from($cfgfile, \e%resource);
\&        $wkf\->inst(\e%path);
\&
\&        # Submit to SGE
\&        $wkf\->run({ conf => \e%resource, dryrun => $dryrun });
\&
\&        # Make use of inline files to store script templates.
\&
\&        _\|_GATK_DOC_\|_
\&        read BAMFILE _PARDIR_/_TASK_
\&
\&        IID=$(basename $BAMFILE)
\&        IID=${IID%.bam}
\&
\&        _PATH.JAVA_ \-jar _PATH.GATK_  \e
\&            \-T DepthOfCoverage \e
\&            \-R _FASTA_ \e
\&            \-o _OUT_/$IID.VCRome \e
\&            \-I $BAMFILE \e
\&            \-L _TARGET_ \e
\&            \-ct 10 \-ct 15 \-ct 20 
\&
\&        _\|_PREP_INTV_\|_
\&        for CHR in X Y; do
\&            awk \*(Aq$1=="X"\*(Aq _PATH.TARGET_ > _WRK_/chr${CHR}.bed 
\&            _PATH.JAVA_ \-jar _PICARD_ BedToIntervalList \e
\&                I=_WRK_/chrX_tg.bed \e
\&                O=_WRK_/chrX_tg.$IID.interval_list \e
\&                SD=_WRK_/$BAMFILE 
\&        done
\&
\&        _\|_PICARD_DOC_\|_
\&read BAMFILE _PARDIR_/_TASK_
\&
\&        _PATH.JAVA_ \-jar _PATH.PICARD_ \e
\&            CollectHsMetrics \e
\&            I=$BAMFILE \e
\&            O=_OUT_/$IID.hs_metrics.txt \e
\&            R=_FASTA_ \e
\&            BAIT_INTERVALS=_WRK_/chrX_tg.interval_list \e
\&            TARGET_INTERVALS=_WRK_/chrY.interval_list
.Ve
.SS "\s-1DESCRIPTION\s0"
.IX Subsection "DESCRIPTION"
Each workflow is associated with a standard layout of working directory.
The standard set include \f(CW\*(C`src, par, out, wrk, tmp,\*(C'\fR and \f(CW\*(C`log\*(C'\fR subdirectories.
The content in those subdirs are
.PP
\&\f(CW\*(C`src\*(C'\fR => bash scripts. Each task of the workflow will have its own script file in src,
          prefixed by the task name.
\&\f(CW\*(C`par\*(C'\fR => parameter files for bash scripts. Each script is associated with one or more 
          parameter files in par with the same name prefix. 
\&\f(CW\*(C`out\*(C'\fR => output files
\&\f(CW\*(C`wrk\*(C'\fR => intermediate files, needs further inspection
\&\f(CW\*(C`tmp\*(C'\fR => temporarily files, can remove after finish.
\&\f(CW\*(C`log\*(C'\fR => log files, after execution, stdout and stderr of each task will be stored in two 
          log files in log directory.
.PP
Users can customize the subdir names to be more meaningful to the application.
Users can also specify additional subdirs as key-value pairs like final => 'vcfs'
.PP
Each task can be a single job or an job array with index starting from 1.
Each task will be described by a series of bash command with special
syntax reserved for future substitution (see below). Users can specify
the dependencies between different tasks.
.PP
\fITask Template\fR
.IX Subsection "Task Template"
.PP
Workflow is comprised of a series of tasks that are dependent of each other. 
Usually, each task is a shell script with multiple commands. In defining workflow
we used template to represent the logic steps of each task. The purpose is to separate
those logical steps from options and associated execution enviroment, which are
specified by the workflow users and can be used to instantiate task scripts later.
.PP
Task template is just like normal bash scripts, except for the following reserved syntax.
.ie n .IP "1. Use ""_VARNAME_"" variables to specify replacable variables" 5
.el .IP "1. Use \f(CW_VARNAME_\fR variables to specify replacable variables" 5
.IX Item "1. Use _VARNAME_ variables to specify replacable variables"
Those variables are typically provided by the user via in config files. 
\&\s-1VARNAME\s0 should be \f(CW\*(C`qr/^[A\-Z][A\-Z0\-9\e.]+$/\*(C'\fR. The dot is used to separate section
and variables in the config file. For example, \f(CW\*(C`_\|_PATH.GATK_\|_\*(C'\fR will corrsponds
to the \s-1GATK\s0 software path given in the config file as
.Sp
.Vb 2
\&    [PATH]
\&    GATK=/XX/YY/GATK.jar
.Ve
.Sp
*NOTE1 * We also support variables with multiple values as an array ([A\-Z][A\-Z0\-9\e.]+)\e[([^\e[\e]]*)\e].
For example, \f(CW\*(C`_ARRAY[SEP]_\*(C'\fR specifies an array variable. When substituted into the
script, multiple values will be separated by \s-1SEP\s0 that is given in the square bracket.
.Sp
*NOTE 2* We noted that _VARNAME_ may be in conflict with long options in picard. 
To resolve this issue, we add an option (strict_var) to enforce that non-reserved 
\&\s-1VARNAME\s0 must  contain a separation dot '.'.  However, it may still run the risk of 
conflicting with the reserved variables like _INDEX_.
.Sp
We recommend using Config::Std to parse config files. When no sections is provided
for a variable, the section name should be changed to \*(L"default\*(R".
.ie n .IP "2. Reserved ""VARNAME""" 5
.el .IP "2. Reserved \f(CWVARNAME\fR" 5
.IX Item "2. Reserved VARNAME"
Path names: \f(CW\*(C`_SRCDIR_, _PARDIR_, _LOGDIR_, _OUTDIR_, _WRKDIR_, _TMPDIR_\*(C'\fR,
Plus user provided subdirs.
.Sp
And \f(CW\*(C`_TASK_, _INDEX_\*(C'\fR will be substituted dynamically to the current task name 
and job array index.
.SS "CLASS::new \s-1ROOT,\s0 [,ENGINE, \s-1OPTIONS\s0]"
.IX Subsection "CLASS::new ROOT, [,ENGINE, OPTIONS]"
Create a workflow management object. If rootdir already exist
and not empty, it will croak error. The default engine is \f(CW\*(AqSGE\*(Aq\fR.
Currently supported engines are: c<\s-1BASH, SGE\s0>
.PP
Optionally users can specify additional sub directories, the corresponding special
variable names will be updated. For example, to add a directory \*(L"bwa\*(R", then \f(CW\*(C`BWADIR\*(C'\fR
will be reserved for this special directory.
.SS "dump"
.IX Subsection "dump"
Dump obj to the current rootdir. Data will be stored as a hidden file \*(L".perldat\*(R".
.ie n .SS "$self\->get_subdir [\s-1LABEL\s0]"
.el .SS "\f(CW$self\fP\->get_subdir [\s-1LABEL\s0]"
.IX Subsection "$self->get_subdir [LABEL]"
Return the absolute path of a subdirectory given by label.
.PP
If no label is provided, then return the list of all subdirs,
the return value will be array or hashref depending on context.
.ie n .SS "$self\->add \s-1TEMPLATE\s0 [,OPTIONS]"
.el .SS "\f(CW$self\fP\->add \s-1TEMPLATE\s0 [,OPTIONS]"
.IX Subsection "$self->add TEMPLATE [,OPTIONS]"
Add task into workflow. Task must be added in logical orders.
If B depends on A, then A must be added first. This prevent
potential loops in the dependency graph.
.PP
\&\s-1TEMPLATE\s0 can be a string, a file name or file handle.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\(bu" 5
name
.Sp
Task name. If not provided, it will introspect the template variable name.
.IP "\(bu" 5
depend
.Sp
List of previous added tasks that the current task depends on.
It can be scalar or arrayref.
.Sp
\&\s-1NOTE:\s0 we use \f(CW\*(C`depend\*(C'\fR option to manually deal with dependency between tasks, 
alternatively tasks can also be connected with using expected input/output.
.IP "\(bu" 5
expect
.Sp
The expected output files from this task in an arrayref.
For task with multiple slots, expected file from all slots should be listed.
Length of the array should equal to the nslots/step.
Expected files are specified in path relative to rootdir.
The expected files can be an empty list so the job will be mandatory to run.
.IP "\(bu" 5
callback
.Sp
A callback subroutine used to validate the expected output. If not provided, it will only
check the presence or absence of the file. The function will take expected files per job 
slot as input. The output will be 1 if all files are present and correct, and 0 otherwise.
.IP "\(bu" 5
interp
.Sp
Script interpretor. If unspecified, we assume the task is a bash script.
But users are free to use languages like perl, R, python, etc, and give appropriate
interpretors along with custom options. When non-bash script template is used,
a second bash wrapper script will also be written to the src directory.
.IP "\(bu" 5
commargs
.Sp
For non-bash script: command line arguments to the script. Those arguments
will be appended to bash script wrapper.
.IP "\(bu" 5
nslots
.Sp
When defined, it indicates the task will be a job array, and it gives the total
number of jobs.
.IP "\(bu" 5
step
.Sp
Step size that each job will iterate through slots.
.IP "\(bu" 5
deparray
.Sp
Indicate that each slot of current task depends on each slot of depended jobs.
Require the current job and all jobs it depends on have the same number of slots.
.ie n .SS "$self\->get_all_tasks"
.el .SS "\f(CW$self\fP\->get_all_tasks"
.IX Subsection "$self->get_all_tasks"
Return the ordered list of current tasks names.
.ie n .SS "$self\->check_expected \s-1TASK\s0 [,SLOT]"
.el .SS "\f(CW$self\fP\->check_expected \s-1TASK\s0 [,SLOT]"
.IX Subsection "$self->check_expected TASK [,SLOT]"
Check expected output files for given task and slots.
If a callback is specified for expected output, it will be called to check the output file in
addition to its presence.
.PP
Note: slot index start from 1 regardless of specified start index. When step>1, then multiple slots
will be associated with the same substask.
.PP
It will return the list of expected files that are not correct or missing.
.ie n .SS "$self\->get_num_slots \s-1TASK\s0"
.el .SS "\f(CW$self\fP\->get_num_slots \s-1TASK\s0"
.IX Subsection "$self->get_num_slots TASK"
Return the number of slots for a task.
.ie n .SS "$self\->get_slots_index \s-1TASK\s0"
.el .SS "\f(CW$self\fP\->get_slots_index \s-1TASK\s0"
.IX Subsection "$self->get_slots_index TASK"
Return the index of each subtask.
.SS "get_dep_array"
.IX Subsection "get_dep_array"
Test if current job is an job array and depend on other arrays.
.ie n .SS "$self\->inst [\s-1CONF, REF\s0]"
.el .SS "\f(CW$self\fP\->inst [\s-1CONF, REF\s0]"
.IX Subsection "$self->inst [CONF, REF]"
When no parameters provided, it generates a list of all user configurable variables.
.PP
If \s-1CONF\s0 is provided, the function validate and replace variables with provided values, then write
scripts into src directory. \s-1CONF\s0 can be a config file name and will be read by Config::Simple.
It can also be a data strcutre returned by Config::Simple or Config::Std.
.PP
If \s-1REF\s0 is provided, a sanity check on \s-1CONF\s0 will be performed. If variables not in \s-1REF\s0 is defined
in \s-1CONF,\s0 it is most likely an error in \s-1CONF.\s0
.PP
Note 1: \f(CW\*(C`Config::Simple\*(C'\fR and \f(CW\*(C`Config::Std\*(C'\fR have different syntax for specifying multiple values.
.PP
Note 2: Now support substitution of array variable, and check the variable type.
.ie n .SS "$self\->run \s-1OPTIONS\s0"
.el .SS "\f(CW$self\fP\->run \s-1OPTIONS\s0"
.IX Subsection "$self->run OPTIONS"
The workflow manager will make use the expected outputs to determine un-executed jobs.
If expected output exist, then we assume the task has been finished successfully and 
will be skipped. This default behavior will be overriden by the task dependencies. 
For example, based on the missing output file, task A is rerun. Then all subsequent 
jobs that depends on A will also be rerun regardless of the presence or absence of
the expected output file. When execution under \s-1BASH\s0 engine, outputs will be checked
after each step.
.PP
\&\s-1NOTE:\s0 the existance of expected output does not guarantee the correctness of the
executions of the entire workflow. The content of log files and output files should be 
examined for further details.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\(bu" 5
conf
.Sp
Use \s-1CONF\s0 to provide engine specific information. It can be a data structure
or a ini format configure file, the same as \s-1CONF\s0 accepted by
\&\f(CW\*(C`$self\-\*(C'\fRinst [\s-1CONF\s0]> method.
.Sp
\&\- For \s-1SGE,\s0 the config should provide information about resource allocation 
(typically given in \f(CW\*(C`qsub \-l\*(C'\fR option). The default resource allocations should 
be given under the key 'default', i.e. in the default section of config file.
Then task-specific customization should be specified in sections headed by
the tasknames. If the key starts with '\-', it will be interpreted as extra
command line arguments to \s-1SGE.\s0 By default, we already have \*(L"\-S /bin/bash \-cwd\*(R"
and other standard options providing job name, script, resources, and \s-1IO\s0 redirection.
.Sp
.Vb 3
\& \- For BASH, currently it only execute all tasks sequentially. For job array
\&it uses parallel feature to speedup. User can specify options for C<parallel>
\&for examples number of jobs executed at the same time).
.Ve
.Sp
The runtime config parameters should be written to \s-1PARDIR\s0 directory.
.IP "\(bu" 5
tasks
.Sp
Specify the tasks to be executed. When this option not defined, all jobs will be
executed/submitted according to the default rules above. To execute only a subset of 
jobs, we can provide task names as arrayref, hashref or a scalar (comma or semicolon
separated).
.Sp
The default execution behavior still applies. I.e., only tasks with incomplete 
expected files will be executed. And all downstream tasks that depend on the current 
task will also be mandatory to run even if they are not specified by this option,
unless the \f(CW\*(C`nochain\*(C'\fR option is switched on.
.IP "\(bu" 5
nochain
.Sp
Only execute specified tasks, but do not trigger downstream mandatory tasks to run.
.IP "\(bu" 5
dryrun
.Sp
Only print out commands, but do not execute.
.IP "\(bu" 5
interact
.Sp
\&\s-1BASH\s0 only. Under interactive mode, the workflow will not die if expected files are missing.
.SH "AUTHOR"
.IX Header "AUTHOR"
Xueya Zhou, \f(CW\*(C`<xueyazhou at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-utils at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Utils>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Utils::Workflow
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker (report bugs here)
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Utils>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Utils>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Utils>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Utils/>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2018 Xueya Zhou.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the the Artistic License (1.0). You may obtain a
copy of the full license at:
.PP
<http://www.perlfoundation.org/artistic_license_1_0>
.PP
Aggregation of this Package with a commercial distribution is always
permitted provided that the use of this Package is embedded; that is,
when no overt attempt is made to make this Package's interfaces visible
to the end user of the commercial distribution. Such use shall not be
construed as a distribution of this Package.
.PP
The name of the Copyright Holder may not be used to endorse or promote
products derived from this software without specific prior written
permission.
.PP
\&\s-1THIS PACKAGE IS PROVIDED \*(L"AS IS\*(R" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\s0
