.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FLATDB 1"
.TH FLATDB 1 "2020-11-30" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
flatdb.pl \-\- Query a flat file database.
.SH "USAGE"
.IX Header "USAGE"
flatdb [options] \-in \s-1INPUT\s0 \-f \s-1FILTER\s0 \-out \s-1OUTPUT\s0
.SH "NOTE"
.IX Header "NOTE"
The input file should be database like data table stored in a text file (including csv format)
or in an Excel spreadsheet. The input file must contain a header with appropriate field 
names assigned to each column. The field name should match regex: qr/[A\-Z_][A\-Z0\-9_\e.]*/i
.PP
The output will be tab separated text file, unless csv suffix is given.
.PP
It is possible that multiple values are packed in the same value. We can unpack such fields
before applying the filtering expression. In such case, we need to specify the way we evaluate
data with multiple entries. Is it true when any, all, or first expression to be true?
.SH "REQUIRED ARGUMENTS"
.IX Header "REQUIRED ARGUMENTS"
.IP "\-[\-]in[put] [=] <file>" 4
.IX Item "-[-]in[put] [=] <file>"
Input data file to be checked. Use '\-' to indicate the input is from \s-1STDIN.\s0
When input is from \s-1STDIN,\s0 header is required.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\-[\-]f[ilter] [=] <expr>" 4
.IX Item "-[-]f[ilter] [=] <expr>"
Filtering expression.
.IP "\-[\-]neg[ative]" 4
.IX Item "-[-]neg[ative]"
Negate the filtering expression.
.IP "\-[\-]out[put] [=] <file>" 4
.IX Item "-[-]out[put] [=] <file>"
Output file name. If not provided, will dump to \s-1STDOUT.\s0
.IP "\-[\-]alias [=] <fstr>" 4
.IX Item "-[-]alias [=] <fstr>"
Fields to be renamed. When alias is used, field names in the filtering expression and
in the selected output should all be aliases.
.IP "\-[\-]select [=] <string>" 4
.IX Item "-[-]select [=] <string>"
Selected fields to appear in the output.
.IP "\-[\-]select\-pattern [=] <regex>" 4
.IX Item "-[-]select-pattern [=] <regex>"
Select fields that match the provided regex.
.IP "\-[\-]skip [=] <nrow>" 4
.IX Item "-[-]skip [=] <nrow>"
Number of rows to skip at the begnining.
.IP "\-[\-]fsep [=] <regex>" 4
.IX Item "-[-]fsep [=] <regex>"
For text file: Field separator, the default is comma for csv file
and white space for other types of text file.
.IP "\-[\-]ofsep [=] <string>" 4
.IX Item "-[-]ofsep [=] <string>"
The output field separator, default is tab for text file or comma for csv file.
.IP "\-[\-]sheet [=] <num>" 4
.IX Item "-[-]sheet [=] <num>"
If the input is an Excel workbook, specify the sheet name or number.
.IP "\-[\-]maxrow [=] <num>" 4
.IX Item "-[-]maxrow [=] <num>"
.PD 0
.IP "\-[\-]maxcol [=] <num>" 4
.IX Item "-[-]maxcol [=] <num>"
.PD
For spreadsheet: the max range of columns and rows.
maxcol can also be used when input is from \s-1STDIN\s0 and does not have a header.
.IP "\-[\-]unpack [=] <fields>" 4
.IX Item "-[-]unpack [=] <fields>"
Unpack the values in the given list of fields. When this list is given
it is required that number of unpacked values should be the same in all 
fields in this list.
.IP "\-[\-]vsep [=] <sepchar>" 4
.IX Item "-[-]vsep [=] <sepchar>"
The separator for multiple values in the field, default is \*(L",\*(R".
.IP "\-[\-]dup[action] [=] <action>" 4
.IX Item "-[-]dup[action] [=] <action>"
How to evaluate with multiple values. Evaluate to be true when \*(L"any\*(R", \*(L"all\*(R", \*(L"none\*(R", \*(L"notall\*(R", \*(L"one\*(R",
or \*(L"first\*(R" value is true. Default: any.
