#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use IO::Dir;
use IO::File;
use Data::Dumper;
use FindBin qw|$Bin|;
use File::Copy;
use File::Basename;
use File::Path qw|make_path|;
use Cwd qw|abs_path|;
use Getopt::Lucid qw|:all|;
use List::MoreUtils qw|all uniq|;
use Config::Std;
use Utils::Workflow;
use Utils::Hash qw|merge_conf|;


use lib "$Bin/../lib/";
use Shared qw|read_list|;


############################
## Command line interface ##
############################

my @spec =  (
	Param("conf|c")->valid(sub { -r }),
	Param("vcf")->valid(sub { -r }),
	Param("outdir|out"),
	Param("engine|eng")->valid(sub { $_ eq 'SGE' || $_ eq 'BASH' }),
	Param("prefix"),
	Keypair("param|par"),
	Switch("hard"),
	Switch("as"),
	Switch("help|h"),
	Switch("dryrun|dry"),
	Switch("force")
	);

my $opt = Getopt::Lucid->getopt(\@spec);

if ($opt->get_help) {
	print STDERR <<EOF;
Purpose:
	This is a pipeline script to filter GATK generated VCF by VQSR or hard filter. 

Usage: 
	vcf_file.pl --conf Config --vcf VCF --out OutDir

Options:
	--vcf:	The raw unfiltered VCF file(s). It can be a single merged VCF file or a list
			scattered VCF files.
	--as:   Use allele spcific (AS) mode of VQSR. It requires AS annotations in VCF.
	--hard: Use hard filters instead of default VQSR.
	--prefix: Prefix for output VCF files. The default is the same as input file prefix if input is a 
			  single VCF, or "cohort" if input is a list of VCFs.

Input/output:
	The input VCF file must be generated by GATK joint genotyping. In case of large files, 
	input may be split into multiple files, and can be provided as a list. In latter case, VCF file must 
	be sorted and must have the same sample, and the order of VCF should be in genomic order.

	The output file will be Prefix.recal.vcf.gz if filtered by default VQSR, or Prefix.recal_as.vcf.gz if 
	filtered by allele-specific VQSR, or Prefix.hardfilt.vcf.gz if filtered by hard filters.  
	If input is a list of VCFs, then output file will also be scattered, with names prefix.n.suffix (n=1,2,...).

Dependencies:
	gatk(v4), gatk(v3, invoked by GenomeAnalysisTK), picard, bcftools, tabix.

EOF
	exit 1;
}

$opt->validate({requires => [qw|conf vcf outdir|]});

my $rootdir = $opt->get_outdir;


#############################
## Input files collection  ##
#############################

my $input = $opt->get_vcf;
my @vcfs;
if ( $input =~ /\.vcf\.gz$/ || $input =~ /\.vcf$/ ) {
	@vcfs = ($input);
}
else {
	my $vcfs = read_list($input, { suffix => ['vcf.gz', 'vcf'] });
	@vcfs = values %$vcfs;
}


my %conf = merge_conf($opt->get_conf, $opt->get_param); 
foreach my $VAR (qw|SNP INDEL|) {
	if (exists $conf{"VQSR$VAR"}) {
		foreach my $TERM (qw|ANNOS TRANCHES|) {
			croak "Cannot find $TERM for $VAR" unless defined $conf{"VQSR$VAR"}{$TERM};
			$conf{"VQSR$VAR"}{$TERM} = [split(/,\s/, $conf{"VQSR$VAR"}{$TERM})];
		}
	}
}
$conf{RSRC}{NSPLITS} = scalar(@vcfs);

while(my ($label, $file) = each %{$conf{PATH}}) {
	unless (-f $file) {
		croak "Cannot find file for $label";
	}
}

my $prefix;
if ($opt->get_prefix) {
	$prefix = $opt->get_prefix;
	croak "Prefix cannot contain path separator" if $prefix =~ /\//;
	
}
else {
	if (@vcfs == 1) {
		$prefix = basename($vcfs[0]);
		if ($prefix =~ /\.vcf\.gz$/) {
			$prefix =~ s/\.vcf\.gz$//;
		}
		else {
			$prefix =~ s/\.vcf$//;
		}
	}
	else {
		$prefix = "cohort";
	}
}
if ($opt->get_hard) {
	$prefix = $prefix . ".hardfilt";
}
elsif ($opt->get_as) {
	$prefix = $prefix . ".recal_as";
}
else {
	$prefix = $prefix . ".recal";
}
$conf{PATH}{PREFIX} = $prefix; 


#################################
##  Workflow initialization    ##
##  Working directory setup    ##
#################################

my $wkf = Utils::Workflow->new($rootdir,
	{ engine => $opt->get_engine, force =>  $opt->get_force, strict_var => 1 });

for(my $ii = 1; $ii <= scalar(@vcfs); $ii ++) {
	open my $fout, ">$rootdir/par/INPUT.$ii" or die "Cannot write to INPUT.$ii";
	print $fout $vcfs[$ii-1], "\n";
	make_path "$rootdir/wrk/$ii";
}

write_config %conf, "$rootdir/par/run.conf" unless $opt->get_dryrun;


###########################################
## Workflow initialization and kickstart ##
###########################################

my $lastjob;
if ($opt->get_hard) {
	foreach my $Var (qw|SNP Indel|) {
		my $var = lc($Var);
		$wkf->add(select_var($Var), { name => "Select$Var",
				expect => [ map { ["wrk/$_/$var.vcf.gz", "wrk/$_/$var.vcf.gz.tbi"] } 1..scalar(@vcfs)],
				nslots => scalar(@vcfs) })
			->add(hard_filt($Var), { name => "HardFilt$Var", depend => "Select$Var", deparray => 1,
				expect => [ map { ["wrk/$_/tmp_${var}_hardfilt.vcf.gz", 
								   "wrk/$_/tmp_${var}_hardfilt.vcf.gz.tbi"] } 1..scalar(@vcfs)],
				nslots => scalar(@vcfs) });
	}
	$wkf->add(merge_hardfilt(), { name => "MergeHardFilt", 
			depend => ["HardFiltSNP", "HardFiltIndel"], deparray => 1,
			expect => [ map { ["out/$prefix.$_.vcf.gz", 
							   "out/$prefix.$_.vcf.gz.tbi"] } 1..scalar(@vcfs) ],
			nslots => scalar(@vcfs) });
	$lastjob = "MergeHardFilt";
}
else {
	$wkf->add(sitesonly_vcf(), { name => "SitesOnlyVCF", 
			expect => [ map { ["wrk/$_/hardfilt.vcf.gz", "wrk/$_/hardfilt.vcf.gz.tbi",
							   "wrk/$_/sitesonly.vcf.gz", "wrk/$_/sitesonly.vcf.gz.tbi"] } 1..scalar(@vcfs)],
			nslots => scalar(@vcfs) })
		->add(gather_sitesonly(), { name => "GatherSitesOnly", depend => "SitesOnlyVCF",
			expect => ["wrk/sitesonly.vcf.gz", "wrk/sitesonly.vcf.gz.tbi"] });
	foreach my $Var (qw|SNP Indel|) {
		my $var = lc($Var);
		$wkf->add(recal_var($Var), { name => "Recal$Var", depend => "GatherSitesOnly",
			expect => ["wrk/${var}_recal", "wrk/${var}_recal_model", "wrk/${var}_tranches"] });
	}
	$wkf->add(apply_vqsr(), { name => "ApplyVQSR", depend => ["RecalSNP", "RecalIndel"],
			expect => [ map { ["wrk/$_/tmp_indel_recal.vcf.gz", 
							   "wrk/$_/tmp_indel_recal.vcf.gz.tbi",
							   "out/$prefix.$_.vcf.gz", "out/$prefix.$_.vcf.gz.tbi"] } 1..scalar(@vcfs)],
			nslots => scalar(@vcfs) });
	$lastjob = "ApplyVQSR";
}
if (@vcfs == 1) {
	$wkf->add(fix_name(), { name => "FixName", depend => $lastjob,
		expect => ["out/$prefix.vcf.gz", "out/$prefix.vcf.gz.tbi"] });
}


$wkf->inst(\%conf);
$wkf->run({ conf => $conf{$wkf->{engine}}, dryrun => $opt->get_dryrun  });


############################
## Workflow components    ##
############################

# Apply a excesshet filter then make sites-only VCF
# recalibration will be applied to merged sites-only data
sub sitesonly_vcf {
	my $script = <<'EOF';

read VCFIN < _PARDIR_/INPUT._INDEX_

gatk --java-options "_RSRC.GATKOPT_" \
	VariantFiltration \
	--filter-expression "ExcessHet > _HARDFILT.EXCESSHET_" \
    --filter-name ExcessHet \
    -O _WRKDIR_/_INDEX_/hardfilt.vcf.gz \
    -V $VCFIN

gatk --java-options "_RSRC.GATKOPT_" \
	MakeSitesOnlyVcf \
	--INPUT _WRKDIR_/_INDEX_/hardfilt.vcf.gz \
	--OUTPUT _WRKDIR_/_INDEX_/sitesonly.vcf.gz

EOF
	return $script;
}

sub gather_sitesonly {
	my $script = <<'EOF';

INPUTS=$(perl -e 'print join(" ", map { "I=_WRKDIR_/$_/sitesonly.vcf.gz" } 1.._RSRC.NSPLITS_)')

picard _RSRC.PICARDOPT_ GatherVcfs \
	O=_WRKDIR_/sitesonly.vcf.gz \
	$INPUTS

tabix -p vcf _WRKDIR_/sitesonly.vcf.gz

EOF
	return $script;
}

sub recal_var {
	my ($var) = @_;
	my $script = <<'EOF';

gatk --java-options "_RSRC.GATKOPT_" \
	VariantRecalibrator \
	-V _WRKDIR_/sitesonly.vcf.gz \
	-O _WRKDIR_/var_recal \
	--tranches-file _WRKDIR_/var_tranches \
	--trust-all-polymorphic \
	-tranche _VQSRVAR.TRANCHES[ -tranche ]_ \
	-an _VQSRVAR.ANNOS[ -an ]_ \
    -mode VAR \
    --output-model _WRKDIR_/var_recal_model \
    --max-gaussians _VQSRVAR.MAXGAUSSIANS_ \
    -resource:_VQSRVAR.RSRC[ \
    -resource:]_

EOF
	$script =~ s/var/${\( lc($var) )}/g;
	$script =~ s/VAR/${\( uc($var) )}/g;
	if ($opt->get_as) {
		$script =~ s/VariantRecalibrator/VariantRecalibrator -AS/g;
	}
	return $script;
}

sub apply_vqsr {
	my ($var) = @_;
	my $script = <<'EOF';

gatk --java-options "_RSRC.GATKOPT_" \
	ApplyVQSR \
	-O _WRKDIR_/_INDEX_/tmp_indel_recal.vcf.gz \
	-V _WRKDIR_/_INDEX_/hardfilt.vcf.gz \
	--recal-file _WRKDIR_/indel_recal \
	--tranches-file _WRKDIR_/indel_tranches \
	--truth-sensitivity-filter-level _VQSRINDEL.LEVEL_ \
	-mode INDEL

gatk --java-options "_RSRC.GATKOPT_" \
	ApplyVQSR \
	-O _OUTDIR_/_PATH.PREFIX_._INDEX_.vcf.gz \
	-V _WRKDIR_/_INDEX_/tmp_indel_recal.vcf.gz \
	--recal-file _WRKDIR_/snp_recal \
	--tranches-file _WRKDIR_/snp_tranches \
	--truth-sensitivity-filter-level _VQSRSNP.LEVEL_ \
	-mode SNP

EOF
	if ($opt->get_as) {
		$script =~ s/ApplyVQSR/ApplyVQSR -AS/g;
	}
	return $script;
}


# Select variants before hard filter
sub select_var {
	my ($var) = @_;
	my $script = <<'EOF';

read VCFIN < _PARDIR_/INPUT._INDEX_

EOF
	if ($var eq 'SNP') {
		$script .= <<'EOF';

# MNP will be taken as part of SNP, although we noted GATK does not call MNPs by default
gatk --java-options "_RSRC.GATKOPT_" \
	SelectVariants \
	-V $VCFIN \
	--select-type-to-include SNP \
	--select-type-to-include MNP \
	-O _WRKDIR_/_INDEX_/snp.vcf.gz

EOF
	}
	elsif ($var eq 'Indel') {
		$script .= <<'EOF';

# Mixed triallelic sites will be considered as indel
gatk --java-options "_RSRC.GATKOPT_" \
	SelectVariants \
	-V $VCFIN \
	--select-type-to-include INDEL \
	--select-type-to-include MIXED \
	-O _WRKDIR_/_INDEX_/indel.vcf.gz

EOF

	}
	return $script;
}

sub hard_filt {
	my ($var) = @_;
	my $script = <<'EOF';

gatk --java-options "_RSRC.GATKOPT_" \
	VariantFiltration \
	-V _WRKDIR_/_INDEX_/var.vcf.gz \
	-O _WRKDIR_/_INDEX_/tmp_var_hardfilt.vcf.gz \
	--filter-expression _HARDFILTVAR.FILTEXPR[ \
	--filter-expression ]_ \
	--filter-name _HARDFILTVAR.FILTNAME[ \
	--filter-name ]_

EOF
	$script =~ s/var/${\( lc($var) )}/g;
	$script =~ s/VAR/${\( uc($var) )}/g;
	return $script;
}

sub merge_hardfilt {
	my ($var) = @_;
	my $script = <<'EOF';

# We use GATK3 to merge variants
# picard MergeVcf does not work
# This function has not been ported to gatk4
GenomeAnalysisTK -T CombineVariants -R _PATH.FASTA_ \
	-V:snp   _WRKDIR_/_INDEX_/tmp_snp_hardfilt.vcf.gz \
	-V:indel _WRKDIR_/_INDEX_/tmp_indel_hardfilt.vcf.gz \
	-o _OUTDIR_/_PATH.PREFIX_._INDEX_.vcf.gz \
	-genotypeMergeOptions PRIORITIZE -priority snp,indel

EOF
	return $script;
}

sub fix_name {
	my $script = <<'EOF';

cd _OUTDIR_
ln _PATH.PREFIX_.1.vcf.gz _PATH.PREFIX_.vcf.gz
ln _PATH.PREFIX_.1.vcf.gz.tbi _PATH.PREFIX_.vcf.gz.tbi

sleep 1

EOF
	return $script;
}

