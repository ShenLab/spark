#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use IO::File;
use Data::Dumper;
use FindBin qw|$Bin|;
use File::Copy;
use Cwd qw|abs_path|;
use Getopt::Lucid qw|:all|;
use Config::Std;
use Perl6::Slurp;
use List::MoreUtils qw|uniq|;
use String::ShellQuote;
use Hash::Util qw|lock_hash|;
use Utils::Hash qw|chk_default|;
use Utils::List qw|split_list|;
use Utils::Workflow;
use Utils::Hash qw|merge_conf|;


############################
## Command line interface ##
############################

my @spec =  (
	Param("conf|c")->valid(sub { -r }),
	Param("list|l")->valid(sub { -r }),
	Param("bed|b")->valid(sub { -r }),
	Param("remove")->valid(sub { -r }),
	Param("group")->valid(sub { -r }),
	Param("outdir|out"),
	Param("engine|eng")->valid(sub { $_ eq 'SGE' || $_ eq 'BASH' }),
	Keypair("param|par"),
	Switch("help|h"),
	Switch("dryrun|dry"),
	Switch("force")
	);

my $opt = Getopt::Lucid->getopt(\@spec);

if ($opt->get_help) {
	print STDERR <<'EOF';
Purpose:
	This is a pipeline script to calculate the proportion of samples in a cohort that are callable
	at each targeted base.

Usage:
	callable_merge.pl --conf Conf [--list BEDList] --outdir RootDir 

Options:
	--list: BED file list should have 2 columns per line: path to callable BED and sample ID.
		 	BED should be should be tabix compressed for range-based query. It is typically generated by
		 	MosDepth (with --quantize option). It is possible that one sample have multiple BED files.
		 	Callable regions from multiple files for the same individual will be merged.
		 	The option override the BED file list specified	in the config. 
	--bed:  Target interval list BED file format. Only regions in this file will be considered. 
			The option overrides the target file in config.
	--group: Sample groups. It should have 2 columns per line: IID and GroupID. IID must be found in BAM 
			file list. Each sample is allowed to be associated with multiple groups. When sample groups 
			are provided, callable proportions will be defined on groups and samples without GroupID 
			will be skipped. 
	--remove: A list of bad samples to be excluded.

Notes: 
	In some analysis, we need to quantify if a target region or position have sufficient sequencing depth 
	across many samples. A basic solution is to first calculate per-bp DoC for each sample, then apply 
	some cutoff on DoC across the samples for each targeted region. But it is very time consuming
	to calculate per-bp DoC and takes huge amount of spaces to store such data. 

	A more efficient solution is to pre-define what is considered "callable" (E.g. >=15x) for each
	individual, and stores each individual's callable region in a BED file. Mosdepth's --quantize option
	can be used to quickly merge adjacent bases that fall in the same coverage bins. To calculate the
	percentage of individuals in a cohort that are callable at a genomic position, we can simply "tally" 
	the individual callable regions at that position.

	Callable region may also be defined on a group of individuals. E.g. our baseline filters for de novo
	variants require DoC >=15x in offspring and >=10x in both parents. When sample groups are defined, 
	a locus is callable for the group if and only if all members of the group are callable.

	Each individual can have multiple callable BED files resulting from technical duplicates or multiple
	sequence runs. Callable regions for each individual will be merged by taking the union.

Output:
	Per-base callable proportion will be stored in three different formats:
		perbase_cov.txt.gz: tabix indexed text file, with three columns: Chrom, Position, and Percent
		perbase_cov.bedgraph.gz: tabix indexed bedGraph format, with four columns: Chrom, Start, End and Percent.
					The intervals are half-open and zero-based. Bases with the same callable proportion in 
					perbase_cov.txt.gz are merged into intervals. 
		perbase_cov.bw: Bigwig file converted from bedGraph. 

	There are also cohort level "callalble" region files by applying cutoffs to callable proportions for 
	per-base coverage files:
		E.g. perbase_cov_ge0.8.bed: is the region that per-base callable proportion is >=0.8.

	We also calculated the proportion of callable bases across the targeted region for each sample (or group if 
	sample groups are defined).
		pergroup_pct.txt has two columns: sample or group ID and proportion 

	Cumulative distribution plots will be generated for perbase and pergroup callable proportions:
		perbase_cov_ecdf.png and pergroup_pct_ecdf.png.

Dependencies:
	bedGraphToBigWig is used to create BigWig file from bedGraph.

EOF
	exit 1;
}

$opt->validate({requires => [qw|conf outdir|]});

# Read in config parameters
my %conf = merge_conf($opt->get_conf, $opt->get_param); 
if ($opt->get_list) {
	$conf{PATH}{LIST} = abs_path($opt->get_list);
}
if ($opt->get_remove) {
	$conf{PATH}{REMOVE} = abs_path($opt->get_remove);
}
if ($opt->get_group) {
	$conf{PATH}{GROUP} = abs_path($opt->get_group);
}

foreach my $label (keys %{$conf{PATH}}) {
	my $path = $conf{PATH}{$label};
	unless(-f $path) {
		die "Cannot fild $label file: $path";
	}
}
$conf{PATH}{UTILS} = shell_quote("$Bin/utils");
$conf{PATH}{MODULE} = shell_quote("$Bin/module");

if (defined $conf{PATH}{MASK}) {
	$conf{PARAM}{MASK} = "--mask $conf{PATH}{MASK}";
}
else {
	$conf{PARAM}{MASK} = "";
}

$conf{PARAM}{DUPSAMP} =~ s/^['"]//; $conf{PARAM}{DUPSAMP}  =~ s/['"]$//;
my $dupsamp = qr/$conf{PARAM}{DUPSAMP}/;

#lock_hash_recurse(%conf);
lock_hash(%conf);

##############################
## Workflow initialization  ##
##############################

my $rootdir = $opt->get_outdir;

my $wkf = Utils::Workflow->new($rootdir, 
	{ dir => "bed", engine => $opt->get_engine, force => $opt->get_force, strict_var => 1});

# Prepare input list that excluding bad samples
# If group is provided, will only keep samples with available group label
my (@samps, @groups, $ngroups);
{
	my %remove;
	if (exists $conf{PATH}{REMOVE}) {
		%remove = map { (split)[0] => 1 } slurp $conf{PATH}{REMOVE};
	}
	my %group;
	if (exists $conf{PATH}{GROUP}) {
		open my $fin, $conf{PATH}{GROUP} or die "Cannot open group list";
		while(<$fin>) {
			my ($iid, $gid) = split;
			my $origid = $iid;
			if ($iid =~ /$dupsamp$/) {
				$origid = s/$dupsamp$//;
			}
			push @{$group{$origid}}, $gid;
		}
	}

	my (%keep, %member);
	open my $fin, $conf{PATH}{LIST} or die "Cannot open $conf{PATH}{LIST}";
	while(<$fin>) {
		my ($path, $iid) = split;
		die "Incorrect number of columns of input list" 
			unless defined $path && defined $iid && $iid !~ /^\s*$/;
		die "Cannot find callable file $path for $iid"	unless -f $path;

		my $origid = $iid;
		if ($iid =~ /$dupsamp$/) {
			$origid =~ s/$dupsamp$//;
		}
		next if defined $remove{$origid};
		if (defined $remove{$iid} && !defined $remove{$origid}) {
			warn "$iid appears in the removal list but $origid does not, both will be removed";
			next;
		}

		unless(-f $path) {
			die "Cannot find file for $origid: $path !"
		}
		push @{$keep{$origid}}, $path;

		if (exists $conf{PATH}{GROUP}) {
			if (defined $group{$origid}) {
				foreach my $gid (uniq sort @{$group{$origid}}) {
					push @{$member{$gid}}, $origid;
				}
			}
		}
		else {
			push @{$member{$origid}}, $origid;
		}
	}

	@samps = sort keys %keep;
	open my $fout, ">$rootdir/par/list.txt" or die "Cannot write to par/list.txt";
	foreach my $iid (@samps) {
		foreach my $path (@{$keep{$iid}}) {
			print $fout join("\t", $path, $iid), "\n";
		}
	}

	my @rawgrps = sort keys %member;
	$ngroups = scalar(@rawgrps);
	@groups = split_list(\@rawgrps, $conf{PARAM}{NGROUP});
	open my $flst, ">$rootdir/par/group.txt" or die "Cannot write to par/group.txt";
	for(my $ii = 0; $ii < @groups; $ii ++) {
		my $jj = $ii + 1;
		open my $fgrp, ">$rootdir/tmp/group.$jj.txt" or die "Cannot write to group.$jj.txt";
		foreach my $gid (@{$groups[$ii]}) {
			foreach my $iid (uniq sort @{$member{$gid}}) {
				print $fgrp join("\t", $iid, $gid), "\n";
				print $flst join("\t", $iid, $gid), "\n";
			}
		}
	}
	$conf{PARAM}{NCLUST} = scalar(@groups);
}

if (@groups > 0) {
	printf STDERR "Found a total number of %d samples in %d groups\n",
		scalar(@samps), $ngroups;
}	
else {
	print STDERR "No group with sequenced samples was found\n";
	exit 1;
}

# We may need a formula to determine the nsplit based on sample size and target length
my $nsplit = $conf{PARAM}{NSPLIT};

$wkf->add(prep_input(), { name => 'PrepInput', 
		expect => [ map { "tmp/split.$_.bed" } 1..$nsplit ] })
	->add(collapse_callable(), { name => 'Collapse', nslots => scalar(@groups), 
		expect => [ collapse_outputs() ] })
	->add(tally_callable(), { name => 'TallyCov', depend => 'PrepInput', nslots => $nsplit, 
		expect => [ map { "wrk/split.$_.cov.txt" } 1..$nsplit ] })
	->add(merge_callable(), { name => 'MergeCov', depend => ['Collapse', 'TallyCov'],
		expect => [ "out/perbase_cov.txt.gz",   "out/perbase_cov.txt.gz.tbi", 
				  	"out/perbase_cov.bedgraph.gz", "out/perbase_cov.bedgraph.gz.tbi", "out/perbase_cov.bw", 
					"tmp/perbase_cov.perc.txt", "out/pergroup_pct.txt", "tmp/pergroup_pct.perc.txt" ] })
	->add(plot_ecdf(), { name => 'eCDFPlot', depend => 'MergeCov',
		interp => 'Rscript', expect => ["out/perbase_cov_ecdf.png", 'out/pergroup_pct_ecdf.png'] })
	->add(call_region(), { name => 'CallReg', depend => 'MergeCov',
		expect => [ map { "out/perbase_cov_ge$_.bed" } split(',', $conf{PARAM}{CUTOFF}) ] });

# Write configs to par directory.
write_config %conf, "$rootdir/par/run.conf" unless $opt->get_dryrun;

$wkf->inst(\%conf);
$wkf->run({ conf => $conf{$wkf->{engine}}, dryrun => $opt->get_dryrun });



############################
## Workflow components    ##
############################

sub prep_input {
	my $script =<<'EOF';

# Split targets into NSPLIT regions with similar total length
split_bed.pl --bed _PATH.TARGETS_ --nsplit _PARAM.NSPLIT_ --out _TMPDIR_/split

EOF
}

sub tally_callable {
	my $script =<<'EOF'

perl _PATH.UTILS_/tally_callable.pl --list _PARDIR_/list.txt --bed _TMPDIR_/split._INDEX_.bed \
	--group _PARDIR_/group.txt --label _PARAM.LABEL_ --ignore _PARAM.DUPSAMP_ \
	--output _WRKDIR_/split._INDEX_.cov.txt _PARAM.MASK_

EOF
}

sub collapse_callable {
	my $script =<<'EOF';

perl _PATH.UTILS_/collapse_callable.pl --list _PARDIR_/list.txt --bed _PATH.TARGETS_ \
 	--group _TMPDIR_/group._INDEX_.txt --label _PARAM.LABEL_ --ignore _PARAM.DUPSAMP_ \
 	--output _WRKDIR_/group._INDEX_.pct.txt --outdir _BEDDIR_ _PARAM.MASK_

EOF
}

sub collapse_outputs {
	my @exps;
	for(my $ii = 0; $ii < @groups; $ii ++) {
		my $jj = $ii + 1;
		my @exp;
		push @exp, "wrk/group.$jj.pct.txt";
		foreach my $gid (@{$groups[$ii]}) { 
			unless(exists $conf{PATH}{GROUP}) {
				next if $gid =~ /$dupsamp/;
			}
			push @exp, "bed/$gid.callable.bed";
		}
		push @exps, \@exp;
	}
	return @exps;
}

sub merge_callable {
	my $script =<<'EOF';

NS=$(find _WRKDIR_ -name 'split.*.cov.txt' | wc -l | awk '{print $1}')
if [[ $NS != _PARAM.NSPLIT_ ]]; then
	echo "Incorrect number of split files: $NS <> _PARAM.NSPLIT_" 2>&1
	exit 100
fi

NG=$(find _WRKDIR_ -name 'group.*.pct.txt' | wc -l | awk '{print $1}')
if [[ $NG != _PARAM.NCLUST_ ]]; then 
	echo "Incorrect number of group clusters: $NG <> _PARAM.NCLUST_" 2>&1
	exit 100
fi

find _WRKDIR_ -name 'split.*.cov.txt' | xargs cat | sort -V -k1,1 -k2,2n | \
	bgzip -c > _OUTDIR_/perbase_cov.txt.gz
tabix -s 1 -b 2 -e 2 _OUTDIR_/perbase_cov.txt.gz

# Convert to bedGraph and bigWig

perl _PATH.MODULE_/convert_pbcov2bedgraph.pl _OUTDIR_/perbase_cov

# Prepare intermediate files for plotting

zcat _OUTDIR_/perbase_cov.txt.gz | cut -f3 > _TMPDIR_/perbase_cov.perc.txt

find _WRKDIR_ -name 'group.*.pct.txt' | xargs cat | sort -k1,1 > _OUTDIR_/pergroup_pct.txt

cut -f2 _OUTDIR_/pergroup_pct.txt > _TMPDIR_/pergroup_pct.perc.txt

EOF
}

sub plot_ecdf {
	my $script =<<'EOF';
perc<-scan("_TMPDIR_/perbase_cov.perc.txt")
perc.ordered<-sort(perc)
png("_OUTDIR_/perbase_cov_ecdf.png", width=5, height=5, unit="in", res=300)
plot(1:length(perc.ordered)/length(perc.ordered), perc.ordered, type="s", ylim=c(0,1),
	xlab="Sample quantile of percentage", ylab="Percent of callable groups",
	main="ECDF") 
dev.off()

perc<-scan("_TMPDIR_/pergroup_pct.perc.txt")
perc.ordered<-sort(perc)
png("_OUTDIR_/pergroup_pct_ecdf.png", width=5, height=5, unit="in", res=300)
plot(1:length(perc.ordered)/length(perc.ordered), perc.ordered, type="s", ylim=c(0,1),
	xlab="Sample quantile of percentage", ylab="Percent of callable target bases",
	main="ECDF") 
dev.off()
EOF
}

sub call_region {
	my $script =<<'EOF';
	
perl _PATH.MODULE_/pbcov2bed.pl _OUTDIR_/perbase_cov.txt.gz _PARAM.CUTOFF_ _OUTDIR_/perbase_cov

EOF
}
